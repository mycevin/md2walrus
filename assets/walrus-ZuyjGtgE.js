function yu(t){return t&&t.__esModule&&Object.prototype.hasOwnProperty.call(t,"default")?t.default:t}const wu="â€¦";function Yp(t){if(t.length<=6)return t;const e=t.startsWith("0x")?2:0;return`0x${t.slice(e,e+4)}${wu}${t.slice(-4)}`}/*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) */function ai(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function ja(t,e){return Array.isArray(e)?e.length===0?!0:t?e.every(n=>typeof n=="string"):e.every(n=>Number.isSafeInteger(n)):!1}function vu(t){if(typeof t!="function")throw new Error("function expected");return!0}function Dn(t,e){if(typeof e!="string")throw new Error(`${t}: string expected`);return!0}function qr(t){if(!Number.isSafeInteger(t))throw new Error(`invalid integer: ${t}`)}function Er(t){if(!Array.isArray(t))throw new Error("array expected")}function Pa(t,e){if(!ja(!0,e))throw new Error(`${t}: array of strings expected`)}function oi(t,e){if(!ja(!1,e))throw new Error(`${t}: array of numbers expected`)}function Ua(...t){const e=i=>i,n=(i,a)=>o=>i(a(o)),r=t.map(i=>i.encode).reduceRight(n,e),s=t.map(i=>i.decode).reduce(n,e);return{encode:r,decode:s}}function Ra(t){const e=typeof t=="string"?t.split(""):t,n=e.length;Pa("alphabet",e);const r=new Map(e.map((s,i)=>[s,i]));return{encode:s=>(Er(s),s.map(i=>{if(!Number.isSafeInteger(i)||i<0||i>=n)throw new Error(`alphabet.encode: digit index outside alphabet "${i}". Allowed: ${t}`);return e[i]})),decode:s=>(Er(s),s.map(i=>{Dn("alphabet.decode",i);const a=r.get(i);if(a===void 0)throw new Error(`Unknown letter: "${i}". Allowed: ${t}`);return a}))}}function Na(t=""){return Dn("join",t),{encode:e=>(Pa("join.decode",e),e.join(t)),decode:e=>(Dn("join.decode",e),e.split(t))}}function zi(t,e,n){if(e<2)throw new Error(`convertRadix: invalid from=${e}, base cannot be less than 2`);if(n<2)throw new Error(`convertRadix: invalid to=${n}, base cannot be less than 2`);if(Er(t),!t.length)return[];let r=0;const s=[],i=Array.from(t,o=>{if(qr(o),o<0||o>=e)throw new Error(`invalid integer: ${o}`);return o}),a=i.length;for(;;){let o=0,c=!0;for(let l=r;l<a;l++){const u=i[l],h=e*o,g=h+u;if(!Number.isSafeInteger(g)||h/e!==o||g-u!==h)throw new Error("convertRadix: carry overflow");const p=g/n;o=g%n;const m=Math.floor(p);if(i[l]=m,!Number.isSafeInteger(m)||m*n+o!==g)throw new Error("convertRadix: carry overflow");if(c)m?c=!1:r=l;else continue}if(s.push(o),c)break}for(let o=0;o<t.length-1&&t[o]===0;o++)s.push(0);return s.reverse()}const Da=(t,e)=>e===0?t:Da(e,t%e),Ir=(t,e)=>t+(e-Da(t,e)),or=(()=>{let t=[];for(let e=0;e<40;e++)t.push(2**e);return t})();function Os(t,e,n,r){if(Er(t),e<=0||e>32)throw new Error(`convertRadix2: wrong from=${e}`);if(n<=0||n>32)throw new Error(`convertRadix2: wrong to=${n}`);if(Ir(e,n)>32)throw new Error(`convertRadix2: carry overflow from=${e} to=${n} carryBits=${Ir(e,n)}`);let s=0,i=0;const a=or[e],o=or[n]-1,c=[];for(const l of t){if(qr(l),l>=a)throw new Error(`convertRadix2: invalid data word=${l} from=${e}`);if(s=s<<e|l,i+e>32)throw new Error(`convertRadix2: carry overflow pos=${i} from=${e}`);for(i+=e;i>=n;i-=n)c.push((s>>i-n&o)>>>0);const u=or[i];if(u===void 0)throw new Error("invalid carry");s&=u-1}if(s=s<<n-i&o,!r&&i>=e)throw new Error("Excess padding");if(!r&&s>0)throw new Error(`Non-zero padding: ${s}`);return r&&i>0&&c.push(s>>>0),c}function _u(t){qr(t);const e=2**8;return{encode:n=>{if(!ai(n))throw new Error("radix.encode input should be Uint8Array");return zi(Array.from(n),e,t)},decode:n=>(oi("radix.decode",n),Uint8Array.from(zi(n,t,e)))}}function Su(t,e=!1){if(qr(t),t<=0||t>32)throw new Error("radix2: bits should be in (0..32]");if(Ir(8,t)>32||Ir(t,8)>32)throw new Error("radix2: carry overflow");return{encode:n=>{if(!ai(n))throw new Error("radix2.encode input should be Uint8Array");return Os(Array.from(n),8,t,!e)},decode:n=>(oi("radix2.decode",n),Uint8Array.from(Os(n,t,8,e)))}}function Vi(t){return vu(t),function(...e){try{return t.apply(null,e)}catch{}}}const ku=t=>Ua(_u(58),Ra(t),Na("")),za=ku("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz"),xs=Ua(Ra("qpzry9x8gf2tvdw0s3jn54khce6mua7l"),Na("")),Wi=[996825010,642813549,513874426,1027748829,705979059];function wn(t){const e=t>>25;let n=(t&33554431)<<5;for(let r=0;r<Wi.length;r++)(e>>r&1)===1&&(n^=Wi[r]);return n}function Fi(t,e,n=1){const r=t.length;let s=1;for(let i=0;i<r;i++){const a=t.charCodeAt(i);if(a<33||a>126)throw new Error(`Invalid prefix (${t})`);s=wn(s)^a>>5}s=wn(s);for(let i=0;i<r;i++)s=wn(s)^t.charCodeAt(i)&31;for(let i of e)s=wn(s)^i;for(let i=0;i<6;i++)s=wn(s);return s^=n,xs.encode(Os([s%or[30]],30,5,!1))}function Eu(t){const e=t==="bech32"?1:734539939,n=Su(5),r=n.decode,s=n.encode,i=Vi(r);function a(h,g,p=90){Dn("bech32.encode prefix",h),ai(g)&&(g=Array.from(g)),oi("bech32.encode",g);const m=h.length;if(m===0)throw new TypeError(`Invalid prefix length ${m}`);const b=m+7+g.length;if(p!==!1&&b>p)throw new TypeError(`Length ${b} exceeds limit ${p}`);const y=h.toLowerCase(),k=Fi(y,g,e);return`${y}1${xs.encode(g)}${k}`}function o(h,g=90){Dn("bech32.decode input",h);const p=h.length;if(p<8||g!==!1&&p>g)throw new TypeError(`invalid string length: ${p} (${h}). Expected (8..${g})`);const m=h.toLowerCase();if(h!==m&&h!==h.toUpperCase())throw new Error("String must be lowercase or uppercase");const b=m.lastIndexOf("1");if(b===0||b===-1)throw new Error('Letter "1" must be present between prefix and data only');const y=m.slice(0,b),k=m.slice(b+1);if(k.length<6)throw new Error("Data must be at least 6 characters long");const A=xs.decode(k).slice(0,-6),j=Fi(y,A,e);if(!k.endsWith(j))throw new Error(`Invalid checksum in ${h}: expected "${j}"`);return{prefix:y,words:A}}const c=Vi(o);function l(h){const{prefix:g,words:p}=o(h,!1);return{prefix:g,words:p,bytes:r(p)}}function u(h,g){return a(h,s(g))}return{encode:a,decode:o,encodeFromBytes:u,decodeToBytes:l,decodeUnsafe:c,fromWords:r,fromWordsUnsafe:i,toWords:s}}const Zp=Eu("bech32"),Kr=t=>za.encode(t),zn=t=>za.decode(t);function Q(t){return Uint8Array.from(atob(t),e=>e.charCodeAt(0))}const rs=8192;function X(t){if(t.length<rs)return btoa(String.fromCharCode(...t));let e="";for(var n=0;n<t.length;n+=rs){const r=t.slice(n,n+rs);e+=String.fromCharCode(...r)}return btoa(e)}function Va(t){const e=t.startsWith("0x")?t.slice(2):t,n=e.length%2===0?e:`0${e}`,r=n.match(/[0-9a-fA-F]{2}/g)?.map(s=>parseInt(s,16))??[];if(r.length!==n.length/2)throw new Error(`Invalid hex string ${t}`);return Uint8Array.from(r)}function hn(t){return t.reduce((e,n)=>e+n.toString(16).padStart(2,"0"),"")}function fn(t,e){return Array.from({length:Math.ceil(t.length/e)},(n,r)=>t.slice(r*e,(r+1)*e))}function eg(){let t,e;return{promise:new Promise((r,s)=>{t=r,e=s}),resolve:t,reject:e}}let Wa=class{constructor(e,n){if(typeof e!="function")throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but got: ${e}.`);this._batchLoadFn=e,this._maxBatchSize=Ou(n),this._batchScheduleFn=xu(n),this._cacheKeyFn=Mu(n),this._cacheMap=Au(n),this._batch=null,this.name=Bu(n)}load(e){if(e==null)throw new TypeError(`The loader.load() function must be called with a value, but got: ${String(e)}.`);const n=Tu(this),r=this._cacheMap;let s;if(r){s=this._cacheKeyFn(e);const a=r.get(s);if(a){const o=n.cacheHits||(n.cacheHits=[]);return new Promise(c=>{o.push(()=>{c(a)})})}}n.keys.push(e);const i=new Promise((a,o)=>{n.callbacks.push({resolve:a,reject:o})});return r&&r.set(s,i),i}loadMany(e){if(!Fa(e))throw new TypeError(`The loader.loadMany() function must be called with Array<key>, but got: ${e}.`);const n=[];for(let r=0;r<e.length;r++)n.push(this.load(e[r]).catch(s=>s));return Promise.all(n)}clear(e){const n=this._cacheMap;if(n){const r=this._cacheKeyFn(e);n.delete(r)}return this}clearAll(){const e=this._cacheMap;return e&&e.clear(),this}prime(e,n){const r=this._cacheMap;if(r){const s=this._cacheKeyFn(e);if(r.get(s)===void 0){let i;n instanceof Error?(i=Promise.reject(n),i.catch(()=>{})):i=Promise.resolve(n),r.set(s,i)}}return this}};const Iu=typeof process=="object"&&typeof process.nextTick=="function"?function(t){ss||(ss=Promise.resolve()),ss.then(()=>{process.nextTick(t)})}:typeof setImmediate=="function"?function(t){setImmediate(t)}:function(t){setTimeout(t)};let ss;function Tu(t){const e=t._batch;if(e!==null&&!e.hasDispatched&&e.keys.length<t._maxBatchSize)return e;const n={hasDispatched:!1,keys:[],callbacks:[]};return t._batch=n,t._batchScheduleFn(()=>{$u(t,n)}),n}function $u(t,e){if(e.hasDispatched=!0,e.keys.length===0){Ms(e);return}let n;try{n=t._batchLoadFn(e.keys)}catch(r){return is(t,e,new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function errored synchronously: ${String(r)}.`))}if(!n||typeof n.then!="function")return is(t,e,new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise: ${String(n)}.`));Promise.resolve(n).then(r=>{if(!Fa(r))throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array: ${String(r)}.`);if(r.length!==e.keys.length)throw new TypeError(`DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys.

Keys:
${String(e.keys)}

Values:
${String(r)}`);Ms(e);for(let s=0;s<e.callbacks.length;s++){const i=r[s];i instanceof Error?e.callbacks[s].reject(i):e.callbacks[s].resolve(i)}}).catch(r=>{is(t,e,r)})}function is(t,e,n){Ms(e);for(let r=0;r<e.keys.length;r++)t.clear(e.keys[r]),e.callbacks[r].reject(n)}function Ms(t){if(t.cacheHits)for(let e=0;e<t.cacheHits.length;e++)t.cacheHits[e]()}function Ou(t){if(!(!t||t.batch!==!1))return 1;const n=t&&t.maxBatchSize;if(n===void 0)return 1/0;if(typeof n!="number"||n<1)throw new TypeError(`maxBatchSize must be a positive number: ${n}`);return n}function xu(t){const e=t&&t.batchScheduleFn;if(e===void 0)return Iu;if(typeof e!="function")throw new TypeError(`batchScheduleFn must be a function: ${e}`);return e}function Mu(t){const e=t&&t.cacheKeyFn;if(e===void 0)return n=>n;if(typeof e!="function")throw new TypeError(`cacheKeyFn must be a function: ${e}`);return e}function Au(t){if(!(!t||t.cache!==!1))return null;const n=t&&t.cacheMap;if(n===void 0)return new Map;if(n!==null){const s=["get","set","delete","clear"].filter(i=>n&&typeof n[i]!="function");if(s.length!==0)throw new TypeError("Custom cacheMap missing methods: "+s.join(", "))}return n}function Bu(t){return t&&t.name?t.name:null}function Fa(t){return typeof t=="object"&&t!==null&&"length"in t&&typeof t.length=="number"&&(t.length===0||t.length>0&&Object.prototype.hasOwnProperty.call(t,t.length-1))}function Tr(t){const e=[];let n=0;if(t===0)return[0];for(;t>0;)e[n]=t&127,(t>>=7)&&(e[n]|=128),n+=1;return e}function Cu(t){let e=0,n=0,r=0;for(;;){const s=t[r];if(r+=1,e|=(s&127)<<n,(s&128)===0)break;n+=7}return{value:e,length:r}}class ju{constructor(e){this.bytePosition=0,this.dataView=new DataView(e.buffer,e.byteOffset,e.byteLength)}shift(e){return this.bytePosition+=e,this}read8(){const e=this.dataView.getUint8(this.bytePosition);return this.shift(1),e}read16(){const e=this.dataView.getUint16(this.bytePosition,!0);return this.shift(2),e}read32(){const e=this.dataView.getUint32(this.bytePosition,!0);return this.shift(4),e}read64(){const e=this.read32(),r=this.read32().toString(16)+e.toString(16).padStart(8,"0");return BigInt("0x"+r).toString(10)}read128(){const e=BigInt(this.read64()),r=BigInt(this.read64()).toString(16)+e.toString(16).padStart(16,"0");return BigInt("0x"+r).toString(10)}read256(){const e=BigInt(this.read128()),r=BigInt(this.read128()).toString(16)+e.toString(16).padStart(32,"0");return BigInt("0x"+r).toString(10)}readBytes(e){const n=this.bytePosition+this.dataView.byteOffset,r=new Uint8Array(this.dataView.buffer,n,e);return this.shift(e),r}readULEB(){const e=this.bytePosition+this.dataView.byteOffset,n=new Uint8Array(this.dataView.buffer,e),{value:r,length:s}=Cu(n);return this.shift(s),r}readVec(e){const n=this.readULEB(),r=[];for(let s=0;s<n;s++)r.push(e(this,s,n));return r}}function Pu(t,e){switch(e){case"base58":return Kr(t);case"base64":return X(t);case"hex":return hn(t);default:throw new Error("Unsupported encoding, supported values are: base64, hex")}}function La(t,e=["<",">"]){const[n,r]=e,s=[];let i="",a=0;for(let o=0;o<t.length;o++){const c=t[o];if(c===n&&a++,c===r&&a--,a===0&&c===","){s.push(i.trim()),i="";continue}i+=c}return s.push(i.trim()),s}class Uu{constructor({initialSize:e=1024,maxSize:n=1/0,allocateSize:r=1024}={}){this.bytePosition=0,this.size=e,this.maxSize=n,this.allocateSize=r,this.dataView=new DataView(new ArrayBuffer(e))}ensureSizeOrGrow(e){const n=this.bytePosition+e;if(n>this.size){const r=Math.min(this.maxSize,this.size+this.allocateSize);if(n>r)throw new Error(`Attempting to serialize to BCS, but buffer does not have enough size. Allocated size: ${this.size}, Max size: ${this.maxSize}, Required size: ${n}`);this.size=r;const s=new ArrayBuffer(this.size);new Uint8Array(s).set(new Uint8Array(this.dataView.buffer)),this.dataView=new DataView(s)}}shift(e){return this.bytePosition+=e,this}write8(e){return this.ensureSizeOrGrow(1),this.dataView.setUint8(this.bytePosition,Number(e)),this.shift(1)}write16(e){return this.ensureSizeOrGrow(2),this.dataView.setUint16(this.bytePosition,Number(e),!0),this.shift(2)}write32(e){return this.ensureSizeOrGrow(4),this.dataView.setUint32(this.bytePosition,Number(e),!0),this.shift(4)}write64(e){return as(BigInt(e),8).forEach(n=>this.write8(n)),this}write128(e){return as(BigInt(e),16).forEach(n=>this.write8(n)),this}write256(e){return as(BigInt(e),32).forEach(n=>this.write8(n)),this}writeULEB(e){return Tr(e).forEach(n=>this.write8(n)),this}writeVec(e,n){return this.writeULEB(e.length),Array.from(e).forEach((r,s)=>n(this,r,s,e.length)),this}*[Symbol.iterator](){for(let e=0;e<this.bytePosition;e++)yield this.dataView.getUint8(e);return this.toBytes()}toBytes(){return new Uint8Array(this.dataView.buffer.slice(0,this.bytePosition))}toString(e){return Pu(this.toBytes(),e)}}function as(t,e){const n=new Uint8Array(e);let r=0;for(;t>0;)n[r]=Number(t%BigInt(256)),t=t/BigInt(256),r+=1;return n}var Ga=t=>{throw TypeError(t)},Ha=(t,e,n)=>e.has(t)||Ga("Cannot "+n),Re=(t,e,n)=>(Ha(t,e,"read from private field"),n?n.call(t):e.get(t)),$r=(t,e,n)=>e.has(t)?Ga("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),Or=(t,e,n,r)=>(Ha(t,e,"write to private field"),e.set(t,n),n),Zt,Tn,cr,bt;const Ru=class qa{constructor(e){$r(this,Zt),$r(this,Tn),this.name=e.name,this.read=e.read,this.serializedSize=e.serializedSize??(()=>null),Or(this,Zt,e.write),Or(this,Tn,e.serialize??((n,r)=>{const s=new Uu({initialSize:this.serializedSize(n)??void 0,...r});return Re(this,Zt).call(this,n,s),s.toBytes()})),this.validate=e.validate??(()=>{})}write(e,n){this.validate(e),Re(this,Zt).call(this,e,n)}serialize(e,n){return this.validate(e),new Nu(this,Re(this,Tn).call(this,e,n))}parse(e){const n=new ju(e);return this.read(n)}fromHex(e){return this.parse(Va(e))}fromBase58(e){return this.parse(zn(e))}fromBase64(e){return this.parse(Q(e))}transform({name:e,input:n,output:r,validate:s}){return new qa({name:e??this.name,read:i=>r?r(this.read(i)):this.read(i),write:(i,a)=>Re(this,Zt).call(this,n?n(i):i,a),serializedSize:i=>this.serializedSize(n?n(i):i),serialize:(i,a)=>Re(this,Tn).call(this,n?n(i):i,a),validate:i=>{s?.(i),this.validate(n?n(i):i)}})}};Zt=new WeakMap;Tn=new WeakMap;let Je=Ru;const Ka=Symbol.for("@mysten/serialized-bcs");function ci(t){return!!t&&typeof t=="object"&&t[Ka]===!0}class Nu{constructor(e,n){$r(this,cr),$r(this,bt),Or(this,cr,e),Or(this,bt,n)}get[Ka](){return!0}toBytes(){return Re(this,bt)}toHex(){return hn(Re(this,bt))}toBase64(){return X(Re(this,bt))}toBase58(){return Kr(Re(this,bt))}parse(){return Re(this,cr).parse(Re(this,bt))}}cr=new WeakMap;bt=new WeakMap;function xr({size:t,...e}){return new Je({...e,serializedSize:()=>t})}function os({readMethod:t,writeMethod:e,...n}){return xr({...n,read:r=>r[t](),write:(r,s)=>s[e](r),validate:r=>{if(r<0||r>n.maxValue)throw new TypeError(`Invalid ${n.name} value: ${r}. Expected value in range 0-${n.maxValue}`);n.validate?.(r)}})}function cs({readMethod:t,writeMethod:e,...n}){return xr({...n,read:r=>r[t](),write:(r,s)=>s[e](BigInt(r)),validate:r=>{const s=BigInt(r);if(s<0||s>n.maxValue)throw new TypeError(`Invalid ${n.name} value: ${s}. Expected value in range 0-${n.maxValue}`);n.validate?.(s)}})}function Du({serialize:t,...e}){const n=new Je({...e,serialize:t,write:(r,s)=>{for(const i of n.serialize(r).toBytes())s.write8(i)}});return n}function zu({toBytes:t,fromBytes:e,...n}){return new Je({...n,read:r=>{const s=r.readULEB(),i=r.readBytes(s);return e(i)},write:(r,s)=>{const i=t(r);s.writeULEB(i.length);for(let a=0;a<i.length;a++)s.write8(i[a])},serialize:r=>{const s=t(r),i=Tr(s.length),a=new Uint8Array(i.length+s.length);return a.set(i,0),a.set(s,i.length),a},validate:r=>{if(typeof r!="string")throw new TypeError(`Invalid ${n.name} value: ${r}. Expected string`);n.validate?.(r)}})}function Vu(t){let e=null;function n(){return e||(e=t()),e}return new Je({name:"lazy",read:r=>n().read(r),serializedSize:r=>n().serializedSize(r),write:(r,s)=>n().write(r,s),serialize:(r,s)=>n().serialize(r,s).toBytes()})}class Qa extends Je{constructor({name:e,fields:n,...r}){const s=Object.entries(n);super({name:e,serializedSize:i=>{let a=0;for(const[o,c]of s){const l=c.serializedSize(i[o]);if(l==null)return null;a+=l}return a},read:i=>{const a={};for(const[o,c]of s)a[o]=c.read(i);return a},write:(i,a)=>{for(const[o,c]of s)c.write(i[o],a)},...r,validate:i=>{if(r?.validate?.(i),typeof i!="object"||i==null)throw new TypeError(`Expected object, found ${typeof i}`)}})}}class Ja extends Je{constructor({fields:e,...n}){const r=Object.entries(e);super({read:s=>{const i=s.readULEB(),a=r[i];if(!a)throw new TypeError(`Unknown value ${i} for enum ${name}`);const[o,c]=a;return{[o]:c?.read(s)??!0,$kind:o}},write:(s,i)=>{const[a,o]=Object.entries(s).filter(([c])=>Object.hasOwn(e,c))[0];for(let c=0;c<r.length;c++){const[l,u]=r[c];if(l===a){i.writeULEB(c),u?.write(o,i);return}}},...n,validate:s=>{if(n?.validate?.(s),typeof s!="object"||s==null)throw new TypeError(`Expected object, found ${typeof s}`);const i=Object.keys(s).filter(o=>s[o]!==void 0&&Object.hasOwn(e,o));if(i.length!==1)throw new TypeError(`Expected object with one key, but found ${i.length} for type ${name}}`);const[a]=i;if(!Object.hasOwn(e,a))throw new TypeError(`Invalid enum variant ${a}`)}})}}class Xa extends Je{constructor({fields:e,name:n,...r}){super({name:n??`(${e.map(s=>s.name).join(", ")})`,serializedSize:s=>{let i=0;for(let a=0;a<e.length;a++){const o=e[a].serializedSize(s[a]);if(o==null)return null;i+=o}return i},read:s=>{const i=[];for(const a of e)i.push(a.read(s));return i},write:(s,i)=>{for(let a=0;a<e.length;a++)e[a].write(s[a],i)},...r,validate:s=>{if(r?.validate?.(s),!Array.isArray(s))throw new TypeError(`Expected array, found ${typeof s}`);if(s.length!==e.length)throw new TypeError(`Expected array of length ${e.length}, found ${s.length}`)}})}}function Wu(t,e,n){return new Je({read:r=>{const s=new Array(t);for(let i=0;i<t;i++)s[i]=e.read(r);return s},write:(r,s)=>{for(const i of r)e.write(i,s)},...n,name:n?.name??`${e.name}[${t}]`,validate:r=>{if(n?.validate?.(r),!r||typeof r!="object"||!("length"in r))throw new TypeError(`Expected array, found ${typeof r}`);if(r.length!==t)throw new TypeError(`Expected array of length ${t}, found ${r.length}`)}})}function Fu(t){return d.enum(`Option<${t.name}>`,{None:null,Some:t}).transform({input:e=>e==null?{None:!0}:{Some:e},output:e=>e.$kind==="Some"?e.Some:null})}function Lu(t,e){return new Je({read:n=>{const r=n.readULEB(),s=new Array(r);for(let i=0;i<r;i++)s[i]=t.read(n);return s},write:(n,r)=>{r.writeULEB(n.length);for(const s of n)t.write(s,r)},...e,name:e?.name??`vector<${t.name}>`,validate:n=>{if(e?.validate?.(n),!n||typeof n!="object"||!("length"in n))throw new TypeError(`Expected array, found ${typeof n}`)}})}function Gu(t,e){return d.vector(d.tuple([t,e])).transform({name:`Map<${t.name}, ${e.name}>`,input:n=>[...n.entries()],output:n=>{const r=new Map;for(const[s,i]of n)r.set(s,i);return r}})}const d={u8(t){return os({readMethod:"read8",writeMethod:"write8",size:1,maxValue:2**8-1,...t,name:t?.name??"u8"})},u16(t){return os({readMethod:"read16",writeMethod:"write16",size:2,maxValue:2**16-1,...t,name:t?.name??"u16"})},u32(t){return os({readMethod:"read32",writeMethod:"write32",size:4,maxValue:2**32-1,...t,name:t?.name??"u32"})},u64(t){return cs({readMethod:"read64",writeMethod:"write64",size:8,maxValue:2n**64n-1n,...t,name:t?.name??"u64"})},u128(t){return cs({readMethod:"read128",writeMethod:"write128",size:16,maxValue:2n**128n-1n,...t,name:t?.name??"u128"})},u256(t){return cs({readMethod:"read256",writeMethod:"write256",size:32,maxValue:2n**256n-1n,...t,name:t?.name??"u256"})},bool(t){return xr({size:1,read:e=>e.read8()===1,write:(e,n)=>n.write8(e?1:0),...t,name:t?.name??"bool",validate:e=>{if(t?.validate?.(e),typeof e!="boolean")throw new TypeError(`Expected boolean, found ${typeof e}`)}})},uleb128(t){return Du({read:e=>e.readULEB(),serialize:e=>Uint8Array.from(Tr(e)),...t,name:t?.name??"uleb128"})},bytes(t,e){return xr({size:t,read:n=>n.readBytes(t),write:(n,r)=>{const s=new Uint8Array(n);for(let i=0;i<t;i++)r.write8(s[i]??0)},...e,name:e?.name??`bytes[${t}]`,validate:n=>{if(e?.validate?.(n),!n||typeof n!="object"||!("length"in n))throw new TypeError(`Expected array, found ${typeof n}`);if(n.length!==t)throw new TypeError(`Expected array of length ${t}, found ${n.length}`)}})},byteVector(t){return new Je({read:e=>{const n=e.readULEB();return e.readBytes(n)},write:(e,n)=>{const r=new Uint8Array(e);n.writeULEB(r.length);for(let s=0;s<r.length;s++)n.write8(r[s]??0)},...t,name:t?.name??"vector<u8>",serializedSize:e=>{const n="length"in e?e.length:null;return n==null?null:Tr(n).length+n},validate:e=>{if(t?.validate?.(e),!e||typeof e!="object"||!("length"in e))throw new TypeError(`Expected array, found ${typeof e}`)}})},string(t){return zu({toBytes:e=>new TextEncoder().encode(e),fromBytes:e=>new TextDecoder().decode(e),...t,name:t?.name??"string"})},fixedArray:Wu,option:Fu,vector:Lu,tuple(t,e){return new Xa({fields:t,...e})},struct(t,e,n){return new Qa({name:t,fields:e,...n})},enum(t,e,n){return new Ja({name:t,fields:e,...n})},map:Gu,lazy(t){return Vu(t)}},Ya=/^(?!.*(^(?!@)|[-.@])($|[-.@]))(?:[a-z0-9-]{0,63}(?:\.[a-z0-9-]{0,63})*)?@[a-z0-9-]{0,63}$/i,Za=/^(?!.*(^|[-.])($|[-.]))(?:[a-z0-9-]{0,63}\.)+sui$/i,Hu=235;function qu(t){return t.length>Hu?!1:t.includes("@")?Ya.test(t):Za.test(t)}function Ku(t,e="at"){const n=t.toLowerCase();let r;if(n.includes("@")){if(!Ya.test(n))throw new Error(`Invalid SuiNS name ${t}`);const[s,i]=n.split("@");r=[...s?s.split("."):[],i]}else{if(!Za.test(n))throw new Error(`Invalid SuiNS name ${t}`);r=n.split(".").slice(0,-1)}return e==="dot"?`${r.join(".")}.sui`:`${r.slice(0,-1).join(".")}@${r[r.length-1]}`}const Qu=/^([a-z0-9]+(?:-[a-z0-9]+)*)$/,Ju=/^\d+$/,Xu=64,eo="/",be=t=>{const e=t.split(eo);if(e.length<2||e.length>3)return!1;const[n,r,s]=e;return s!==void 0&&!Ju.test(s)||!qu(n)?!1:Qu.test(r)&&r.length<Xu},Yu=t=>{const e=t.split(/::|<|>|,/);for(const n of e)if(n.includes(eo)&&!be(n))return!1;return!0},Zu=32;function Li(t){try{return zn(t).length===Zu}catch{return!1}}const Qr=32;function Ne(t){return tl(t)&&nl(t)===Qr}function Jn(t){return Ne(t)}function el(t){return t.includes("::")?ut(t):t}function ut(t){const[e,n]=t.split("::"),r=be(e),s=t.slice(e.length+n.length+4),i=s.includes("<")?s.slice(0,s.indexOf("<")):s,a=s.includes("<")?La(s.slice(s.indexOf("<")+1,s.lastIndexOf(">"))).map(o=>el(o.trim())):[];return{address:r?e:C(e),module:n,name:i,typeParams:a}}function Gt(t){const{address:e,module:n,name:r,typeParams:s}=typeof t=="string"?ut(t):t,i=s?.length>0?`<${s.map(a=>typeof a=="string"?a:Gt(a)).join(",")}>`:"";return`${e}::${n}::${r}${i}`}function C(t,e=!1){let n=t.toLowerCase();return!e&&n.startsWith("0x")&&(n=n.slice(2)),`0x${n.padStart(Qr*2,"0")}`}function ct(t,e=!1){return C(t,e)}function tl(t){return/^(0x|0X)?[a-fA-F0-9]+$/.test(t)&&t.length%2===0}function nl(t){return/^(0x|0X)/.test(t)?(t.length-2)/2:t.length/2}BigInt(1e9);const rl="0x1",to="0x2";ct("0x6");const sl=`${to}::sui::SUI`;ct("0x5");const Xt=typeof globalThis=="object"&&"crypto"in globalThis?globalThis.crypto:void 0;/*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) */function il(t){return t instanceof Uint8Array||ArrayBuffer.isView(t)&&t.constructor.name==="Uint8Array"}function Vn(t){if(!Number.isSafeInteger(t)||t<0)throw new Error("positive integer expected, got "+t)}function Kt(t,...e){if(!il(t))throw new Error("Uint8Array expected");if(e.length>0&&!e.includes(t.length))throw new Error("Uint8Array expected of length "+e+", got length="+t.length)}function ng(t){if(typeof t!="function"||typeof t.create!="function")throw new Error("Hash should be wrapped by utils.createHasher");Vn(t.outputLen),Vn(t.blockLen)}function Mr(t,e=!0){if(t.destroyed)throw new Error("Hash instance has been destroyed");if(e&&t.finished)throw new Error("Hash#digest() has already been called")}function no(t,e){Kt(t);const n=e.outputLen;if(t.length<n)throw new Error("digestInto() expects output buffer of length at least "+n)}function Ar(t){return new Uint32Array(t.buffer,t.byteOffset,Math.floor(t.byteLength/4))}function Br(...t){for(let e=0;e<t.length;e++)t[e].fill(0)}function us(t){return new DataView(t.buffer,t.byteOffset,t.byteLength)}function rg(t,e){return t<<32-e|t>>>e}const ro=new Uint8Array(new Uint32Array([287454020]).buffer)[0]===68;function so(t){return t<<24&4278190080|t<<8&16711680|t>>>8&65280|t>>>24&255}const nt=ro?t=>t:t=>so(t);function al(t){for(let e=0;e<t.length;e++)t[e]=so(t[e]);return t}const Yt=ro?t=>t:al,io=typeof Uint8Array.from([]).toHex=="function"&&typeof Uint8Array.fromHex=="function",ol=Array.from({length:256},(t,e)=>e.toString(16).padStart(2,"0"));function sg(t){if(Kt(t),io)return t.toHex();let e="";for(let n=0;n<t.length;n++)e+=ol[t[n]];return e}const Ze={_0:48,_9:57,A:65,F:70,a:97,f:102};function Gi(t){if(t>=Ze._0&&t<=Ze._9)return t-Ze._0;if(t>=Ze.A&&t<=Ze.F)return t-(Ze.A-10);if(t>=Ze.a&&t<=Ze.f)return t-(Ze.a-10)}function ig(t){if(typeof t!="string")throw new Error("hex string expected, got "+typeof t);if(io)return Uint8Array.fromHex(t);const e=t.length,n=e/2;if(e%2)throw new Error("hex string expected, got unpadded hex of length "+e);const r=new Uint8Array(n);for(let s=0,i=0;s<n;s++,i+=2){const a=Gi(t.charCodeAt(i)),o=Gi(t.charCodeAt(i+1));if(a===void 0||o===void 0){const c=t[i]+t[i+1];throw new Error('hex string expected, got non-hex character "'+c+'" at index '+i)}r[s]=a*16+o}return r}function ao(t){if(typeof t!="string")throw new Error("string expected");return new Uint8Array(new TextEncoder().encode(t))}function Wt(t){return typeof t=="string"&&(t=ao(t)),Kt(t),t}function ag(t){return typeof t=="string"&&(t=ao(t)),Kt(t),t}function og(...t){let e=0;for(let r=0;r<t.length;r++){const s=t[r];Kt(s),e+=s.length}const n=new Uint8Array(e);for(let r=0,s=0;r<t.length;r++){const i=t[r];n.set(i,s),s+=i.length}return n}function cg(t,e){if(e!==void 0&&{}.toString.call(e)!=="[object Object]")throw new Error("options should be object or undefined");return Object.assign(t,e)}class oo{}function ug(t){const e=r=>t().update(Wt(r)).digest(),n=t();return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=()=>t(),e}function cl(t){const e=(r,s)=>t(s).update(Wt(r)).digest(),n=t({});return e.outputLen=n.outputLen,e.blockLen=n.blockLen,e.create=r=>t(r),e}function lg(t=32){if(Xt&&typeof Xt.getRandomValues=="function")return Xt.getRandomValues(new Uint8Array(t));if(Xt&&typeof Xt.randomBytes=="function")return Uint8Array.from(Xt.randomBytes(t));throw new Error("crypto.getRandomValues must be defined")}const ul=Uint8Array.from([0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9,12,5,1,15,14,13,4,10,0,7,6,3,9,2,8,11,13,11,7,14,12,1,3,9,5,0,15,4,8,6,2,10,6,15,14,9,11,3,0,8,12,2,13,7,1,4,10,5,10,2,8,4,7,6,1,5,15,11,9,14,3,12,13,0,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,14,10,4,8,9,15,13,6,1,12,0,2,11,7,5,3,11,8,12,0,5,2,15,13,10,14,3,6,7,1,9,4,7,9,3,1,13,12,11,14,2,6,5,10,4,0,15,8,9,0,5,7,2,4,10,15,14,1,11,12,6,8,3,13,2,12,6,10,0,11,8,3,4,13,7,5,15,14,1,9]);function ll(t,e,n,r){if(typeof t.setBigUint64=="function")return t.setBigUint64(e,n,r);const s=BigInt(32),i=BigInt(4294967295),a=Number(n>>s&i),o=Number(n&i),c=r?4:0,l=r?0:4;t.setUint32(e+c,a,r),t.setUint32(e+l,o,r)}function dg(t,e,n){return t&e^~t&n}function hg(t,e,n){return t&e^t&n^e&n}class fg extends oo{constructor(e,n,r,s){super(),this.finished=!1,this.length=0,this.pos=0,this.destroyed=!1,this.blockLen=e,this.outputLen=n,this.padOffset=r,this.isLE=s,this.buffer=new Uint8Array(e),this.view=us(this.buffer)}update(e){Mr(this),e=Wt(e),Kt(e);const{view:n,buffer:r,blockLen:s}=this,i=e.length;for(let a=0;a<i;){const o=Math.min(s-this.pos,i-a);if(o===s){const c=us(e);for(;s<=i-a;a+=s)this.process(c,a);continue}r.set(e.subarray(a,a+o),this.pos),this.pos+=o,a+=o,this.pos===s&&(this.process(n,0),this.pos=0)}return this.length+=e.length,this.roundClean(),this}digestInto(e){Mr(this),no(e,this),this.finished=!0;const{buffer:n,view:r,blockLen:s,isLE:i}=this;let{pos:a}=this;n[a++]=128,Br(this.buffer.subarray(a)),this.padOffset>s-a&&(this.process(r,0),a=0);for(let h=a;h<s;h++)n[h]=0;ll(r,s-8,BigInt(this.length*8),i),this.process(r,0);const o=us(e),c=this.outputLen;if(c%4)throw new Error("_sha2: outputLen should be aligned to 32bit");const l=c/4,u=this.get();if(l>u.length)throw new Error("_sha2: outputLen bigger than state");for(let h=0;h<l;h++)o.setUint32(4*h,u[h],i)}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){e||(e=new this.constructor),e.set(...this.get());const{blockLen:n,buffer:r,length:s,finished:i,destroyed:a,pos:o}=this;return e.destroyed=a,e.finished=i,e.length=s,e.pos=o,s%n&&e.buffer.set(r),e}clone(){return this._cloneInto()}}const pg=Uint32Array.from([1779033703,3144134277,1013904242,2773480762,1359893119,2600822924,528734635,1541459225]),gg=Uint32Array.from([3418070365,3238371032,1654270250,914150663,2438529370,812702999,355462360,4144912697,1731405415,4290775857,2394180231,1750603025,3675008525,1694076839,1203062813,3204075428]),mg=Uint32Array.from([1779033703,4089235720,3144134277,2227873595,1013904242,4271175723,2773480762,1595750129,1359893119,2917565137,2600822924,725511199,528734635,4215389547,1541459225,327033209]),Xn=BigInt(2**32-1),Hi=BigInt(32);function co(t,e=!1){return e?{h:Number(t&Xn),l:Number(t>>Hi&Xn)}:{h:Number(t>>Hi&Xn)|0,l:Number(t&Xn)|0}}function bg(t,e=!1){const n=t.length;let r=new Uint32Array(n),s=new Uint32Array(n);for(let i=0;i<n;i++){const{h:a,l:o}=co(t[i],e);[r[i],s[i]]=[a,o]}return[r,s]}const yg=(t,e,n)=>t>>>n,wg=(t,e,n)=>t<<32-n|e>>>n,uo=(t,e,n)=>t>>>n|e<<32-n,lo=(t,e,n)=>t<<32-n|e>>>n,dl=(t,e,n)=>t<<64-n|e>>>n-32,hl=(t,e,n)=>t>>>n-32|e<<64-n,fl=(t,e)=>e,pl=(t,e)=>t;function ho(t,e,n,r){const s=(e>>>0)+(r>>>0);return{h:t+n+(s/2**32|0)|0,l:s|0}}const fo=(t,e,n)=>(t>>>0)+(e>>>0)+(n>>>0),po=(t,e,n,r)=>e+n+r+(t/2**32|0)|0,vg=(t,e,n,r)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0),_g=(t,e,n,r,s)=>e+n+r+s+(t/2**32|0)|0,Sg=(t,e,n,r,s)=>(t>>>0)+(e>>>0)+(n>>>0)+(r>>>0)+(s>>>0),kg=(t,e,n,r,s,i)=>e+n+r+s+i+(t/2**32|0)|0,H=Uint32Array.from([4089235720,1779033703,2227873595,3144134277,4271175723,1013904242,1595750129,2773480762,2917565137,1359893119,725511199,2600822924,4215389547,528734635,327033209,1541459225]),_=new Uint32Array(32);function ft(t,e,n,r,s,i){const a=s[i],o=s[i+1];let c=_[2*t],l=_[2*t+1],u=_[2*e],h=_[2*e+1],g=_[2*n],p=_[2*n+1],m=_[2*r],b=_[2*r+1],y=fo(c,u,a);l=po(y,l,h,o),c=y|0,{Dh:b,Dl:m}={Dh:b^l,Dl:m^c},{Dh:b,Dl:m}={Dh:fl(b,m),Dl:pl(b)},{h:p,l:g}=ho(p,g,b,m),{Bh:h,Bl:u}={Bh:h^p,Bl:u^g},{Bh:h,Bl:u}={Bh:uo(h,u,24),Bl:lo(h,u,24)},_[2*t]=c,_[2*t+1]=l,_[2*e]=u,_[2*e+1]=h,_[2*n]=g,_[2*n+1]=p,_[2*r]=m,_[2*r+1]=b}function pt(t,e,n,r,s,i){const a=s[i],o=s[i+1];let c=_[2*t],l=_[2*t+1],u=_[2*e],h=_[2*e+1],g=_[2*n],p=_[2*n+1],m=_[2*r],b=_[2*r+1],y=fo(c,u,a);l=po(y,l,h,o),c=y|0,{Dh:b,Dl:m}={Dh:b^l,Dl:m^c},{Dh:b,Dl:m}={Dh:uo(b,m,16),Dl:lo(b,m,16)},{h:p,l:g}=ho(p,g,b,m),{Bh:h,Bl:u}={Bh:h^p,Bl:u^g},{Bh:h,Bl:u}={Bh:dl(h,u,63),Bl:hl(h,u,63)},_[2*t]=c,_[2*t+1]=l,_[2*e]=u,_[2*e+1]=h,_[2*n]=g,_[2*n+1]=p,_[2*r]=m,_[2*r+1]=b}function gl(t,e={},n,r,s){if(Vn(n),t<0||t>n)throw new Error("outputLen bigger than keyLen");const{key:i,salt:a,personalization:o}=e;if(i!==void 0&&(i.length<1||i.length>n))throw new Error("key length must be undefined or 1.."+n);if(a!==void 0&&a.length!==r)throw new Error("salt must be undefined or "+r);if(o!==void 0&&o.length!==s)throw new Error("personalization must be undefined or "+s)}class ml extends oo{constructor(e,n){super(),this.finished=!1,this.destroyed=!1,this.length=0,this.pos=0,Vn(e),Vn(n),this.blockLen=e,this.outputLen=n,this.buffer=new Uint8Array(e),this.buffer32=Ar(this.buffer)}update(e){Mr(this),e=Wt(e),Kt(e);const{blockLen:n,buffer:r,buffer32:s}=this,i=e.length,a=e.byteOffset,o=e.buffer;for(let c=0;c<i;){this.pos===n&&(Yt(s),this.compress(s,0,!1),Yt(s),this.pos=0);const l=Math.min(n-this.pos,i-c),u=a+c;if(l===n&&!(u%4)&&c+l<i){const h=new Uint32Array(o,u,Math.floor((i-c)/4));Yt(h);for(let g=0;c+n<i;g+=s.length,c+=n)this.length+=n,this.compress(h,g,!1);Yt(h);continue}r.set(e.subarray(c,c+l),this.pos),this.pos+=l,this.length+=l,c+=l}return this}digestInto(e){Mr(this),no(e,this);const{pos:n,buffer32:r}=this;this.finished=!0,Br(this.buffer.subarray(n)),Yt(r),this.compress(r,0,!0),Yt(r);const s=Ar(e);this.get().forEach((i,a)=>s[a]=nt(i))}digest(){const{buffer:e,outputLen:n}=this;this.digestInto(e);const r=e.slice(0,n);return this.destroy(),r}_cloneInto(e){const{buffer:n,length:r,finished:s,destroyed:i,outputLen:a,pos:o}=this;return e||(e=new this.constructor({dkLen:a})),e.set(...this.get()),e.buffer.set(n),e.destroyed=i,e.finished=s,e.length=r,e.pos=o,e.outputLen=a,e}clone(){return this._cloneInto()}}class bl extends ml{constructor(e={}){const n=e.dkLen===void 0?64:e.dkLen;super(128,n),this.v0l=H[0]|0,this.v0h=H[1]|0,this.v1l=H[2]|0,this.v1h=H[3]|0,this.v2l=H[4]|0,this.v2h=H[5]|0,this.v3l=H[6]|0,this.v3h=H[7]|0,this.v4l=H[8]|0,this.v4h=H[9]|0,this.v5l=H[10]|0,this.v5h=H[11]|0,this.v6l=H[12]|0,this.v6h=H[13]|0,this.v7l=H[14]|0,this.v7h=H[15]|0,gl(n,e,64,16,16);let{key:r,personalization:s,salt:i}=e,a=0;if(r!==void 0&&(r=Wt(r),a=r.length),this.v0l^=this.outputLen|a<<8|65536|1<<24,i!==void 0){i=Wt(i);const o=Ar(i);this.v4l^=nt(o[0]),this.v4h^=nt(o[1]),this.v5l^=nt(o[2]),this.v5h^=nt(o[3])}if(s!==void 0){s=Wt(s);const o=Ar(s);this.v6l^=nt(o[0]),this.v6h^=nt(o[1]),this.v7l^=nt(o[2]),this.v7h^=nt(o[3])}if(r!==void 0){const o=new Uint8Array(this.blockLen);o.set(r),this.update(o)}}get(){let{v0l:e,v0h:n,v1l:r,v1h:s,v2l:i,v2h:a,v3l:o,v3h:c,v4l:l,v4h:u,v5l:h,v5h:g,v6l:p,v6h:m,v7l:b,v7h:y}=this;return[e,n,r,s,i,a,o,c,l,u,h,g,p,m,b,y]}set(e,n,r,s,i,a,o,c,l,u,h,g,p,m,b,y){this.v0l=e|0,this.v0h=n|0,this.v1l=r|0,this.v1h=s|0,this.v2l=i|0,this.v2h=a|0,this.v3l=o|0,this.v3h=c|0,this.v4l=l|0,this.v4h=u|0,this.v5l=h|0,this.v5h=g|0,this.v6l=p|0,this.v6h=m|0,this.v7l=b|0,this.v7h=y|0}compress(e,n,r){this.get().forEach((c,l)=>_[l]=c),_.set(H,16);let{h:s,l:i}=co(BigInt(this.length));_[24]=H[8]^i,_[25]=H[9]^s,r&&(_[28]=~_[28],_[29]=~_[29]);let a=0;const o=ul;for(let c=0;c<12;c++)ft(0,4,8,12,e,n+2*o[a++]),pt(0,4,8,12,e,n+2*o[a++]),ft(1,5,9,13,e,n+2*o[a++]),pt(1,5,9,13,e,n+2*o[a++]),ft(2,6,10,14,e,n+2*o[a++]),pt(2,6,10,14,e,n+2*o[a++]),ft(3,7,11,15,e,n+2*o[a++]),pt(3,7,11,15,e,n+2*o[a++]),ft(0,5,10,15,e,n+2*o[a++]),pt(0,5,10,15,e,n+2*o[a++]),ft(1,6,11,12,e,n+2*o[a++]),pt(1,6,11,12,e,n+2*o[a++]),ft(2,7,8,13,e,n+2*o[a++]),pt(2,7,8,13,e,n+2*o[a++]),ft(3,4,9,14,e,n+2*o[a++]),pt(3,4,9,14,e,n+2*o[a++]);this.v0l^=_[0]^_[16],this.v0h^=_[1]^_[17],this.v1l^=_[2]^_[18],this.v1h^=_[3]^_[19],this.v2l^=_[4]^_[20],this.v2h^=_[5]^_[21],this.v3l^=_[6]^_[22],this.v3h^=_[7]^_[23],this.v4l^=_[8]^_[24],this.v4h^=_[9]^_[25],this.v5l^=_[10]^_[26],this.v5h^=_[11]^_[27],this.v6l^=_[12]^_[28],this.v6h^=_[13]^_[29],this.v7l^=_[14]^_[30],this.v7h^=_[15]^_[31],Br(_)}destroy(){this.destroyed=!0,Br(this.buffer32),this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0)}}const yl=cl(t=>new bl(t)),go=yl,wl=/^vector<(.+)>$/,vl=/^([^:]+)::([^:]+)::([^<]+)(<(.+)>)?/;class Ie{static parseFromStr(e,n=!1){if(e==="address")return{address:null};if(e==="bool")return{bool:null};if(e==="u8")return{u8:null};if(e==="u16")return{u16:null};if(e==="u32")return{u32:null};if(e==="u64")return{u64:null};if(e==="u128")return{u128:null};if(e==="u256")return{u256:null};if(e==="signer")return{signer:null};const r=e.match(wl);if(r)return{vector:Ie.parseFromStr(r[1],n)};const s=e.match(vl);if(s)return{struct:{address:n?C(s[1]):s[1],module:s[2],name:s[3],typeParams:s[5]===void 0?[]:Ie.parseStructTypeArgs(s[5],n)}};throw new Error(`Encountered unexpected token when parsing type args for ${e}`)}static parseStructTypeArgs(e,n=!1){return La(e).map(r=>Ie.parseFromStr(r,n))}static tagToString(e){if("bool"in e)return"bool";if("u8"in e)return"u8";if("u16"in e)return"u16";if("u32"in e)return"u32";if("u64"in e)return"u64";if("u128"in e)return"u128";if("u256"in e)return"u256";if("address"in e)return"address";if("signer"in e)return"signer";if("vector"in e)return`vector<${Ie.tagToString(e.vector)}>`;if("struct"in e){const n=e.struct,r=n.typeParams.map(Ie.tagToString).join(", ");return`${n.address}::${n.module}::${n.name}${r?`<${r}>`:""}`}throw new Error("Invalid TypeTag")}}function _l(t){return d.u64({name:"unsafe_u64",...t}).transform({input:e=>e,output:e=>Number(e)})}function Sl(t){return d.enum("Option",{None:null,Some:t})}const z=d.bytes(Qr).transform({validate:t=>{const e=typeof t=="string"?t:hn(t);if(!e||!Ne(C(e)))throw new Error(`Invalid Sui address ${e}`)},input:t=>typeof t=="string"?Va(C(t)):t,output:t=>C(hn(t))}),We=d.vector(d.u8()).transform({name:"ObjectDigest",input:t=>zn(t),output:t=>Kr(new Uint8Array(t)),validate:t=>{if(zn(t).length!==32)throw new Error("ObjectDigest must be 32 bytes")}}),ke=d.struct("SuiObjectRef",{objectId:z,version:d.u64(),digest:We}),mo=d.struct("SharedObjectRef",{objectId:z,initialSharedVersion:d.u64(),mutable:d.bool()}),bo=d.enum("ObjectArg",{ImmOrOwnedObject:ke,SharedObject:mo,Receiving:ke}),Rt=d.enum("Owner",{AddressOwner:z,ObjectOwner:z,Shared:d.struct("Shared",{initialSharedVersion:d.u64()}),Immutable:null,ConsensusAddressOwner:d.struct("ConsensusAddressOwner",{owner:z,startVersion:d.u64()})}),yo=d.enum("CallArg",{Pure:d.struct("Pure",{bytes:d.vector(d.u8()).transform({input:t=>typeof t=="string"?Q(t):t,output:t=>X(new Uint8Array(t))})}),Object:bo}),ui=d.enum("TypeTag",{bool:null,u8:null,u64:null,u128:null,address:null,signer:null,vector:d.lazy(()=>ui),struct:d.lazy(()=>Eo),u16:null,u32:null,u256:null}),li=ui.transform({input:t=>typeof t=="string"?Ie.parseFromStr(t,!0):t,output:t=>Ie.tagToString(t)}),He=d.enum("Argument",{GasCoin:null,Input:d.u16(),Result:d.u16(),NestedResult:d.tuple([d.u16(),d.u16()])}),wo=d.struct("ProgrammableMoveCall",{package:z,module:d.string(),function:d.string(),typeArguments:d.vector(li),arguments:d.vector(He)}),vo=d.enum("Command",{MoveCall:wo,TransferObjects:d.struct("TransferObjects",{objects:d.vector(He),address:He}),SplitCoins:d.struct("SplitCoins",{coin:He,amounts:d.vector(He)}),MergeCoins:d.struct("MergeCoins",{destination:He,sources:d.vector(He)}),Publish:d.struct("Publish",{modules:d.vector(d.vector(d.u8()).transform({input:t=>typeof t=="string"?Q(t):t,output:t=>X(new Uint8Array(t))})),dependencies:d.vector(z)}),MakeMoveVec:d.struct("MakeMoveVec",{type:Sl(li).transform({input:t=>t===null?{None:!0}:{Some:t},output:t=>t.Some??null}),elements:d.vector(He)}),Upgrade:d.struct("Upgrade",{modules:d.vector(d.vector(d.u8()).transform({input:t=>typeof t=="string"?Q(t):t,output:t=>X(new Uint8Array(t))})),dependencies:d.vector(z),package:z,ticket:He})}),_o=d.struct("ProgrammableTransaction",{inputs:d.vector(yo),commands:d.vector(vo)}),So=d.enum("TransactionKind",{ProgrammableTransaction:_o,ChangeEpoch:null,Genesis:null,ConsensusCommitPrologue:null}),ko=d.enum("TransactionExpiration",{None:null,Epoch:_l()}),Eo=d.struct("StructTag",{address:z,module:d.string(),name:d.string(),typeParams:d.vector(ui)}),Io=d.struct("GasData",{payment:d.vector(ke),owner:z,price:d.u64(),budget:d.u64()}),To=d.struct("TransactionDataV1",{kind:So,sender:z,gasData:Io,expiration:ko}),$o=d.enum("TransactionData",{V1:To}),Oo=d.enum("IntentScope",{TransactionData:null,TransactionEffects:null,CheckpointSummary:null,PersonalMessage:null}),xo=d.enum("IntentVersion",{V0:null}),Mo=d.enum("AppId",{Sui:null}),Ao=d.struct("Intent",{scope:Oo,version:xo,appId:Mo});function Bo(t){return d.struct(`IntentMessage<${t.name}>`,{intent:Ao,value:t})}const Co=d.enum("CompressedSignature",{ED25519:d.fixedArray(64,d.u8()),Secp256k1:d.fixedArray(64,d.u8()),Secp256r1:d.fixedArray(64,d.u8()),ZkLogin:d.vector(d.u8()),Passkey:d.vector(d.u8())}),jo=d.enum("PublicKey",{ED25519:d.fixedArray(32,d.u8()),Secp256k1:d.fixedArray(33,d.u8()),Secp256r1:d.fixedArray(33,d.u8()),ZkLogin:d.vector(d.u8()),Passkey:d.fixedArray(33,d.u8())}),Po=d.struct("MultiSigPkMap",{pubKey:jo,weight:d.u8()}),Uo=d.struct("MultiSigPublicKey",{pk_map:d.vector(Po),threshold:d.u16()}),kl=d.struct("MultiSig",{sigs:d.vector(Co),bitmap:d.u16(),multisig_pk:Uo}),El=d.vector(d.u8()).transform({input:t=>typeof t=="string"?Q(t):t,output:t=>X(new Uint8Array(t))}),Ro=d.struct("SenderSignedTransaction",{intentMessage:Bo($o),txSignatures:d.vector(El)}),Il=d.vector(Ro,{name:"SenderSignedData"}),Tl=d.struct("PasskeyAuthenticator",{authenticatorData:d.vector(d.u8()),clientDataJson:d.string(),userSignature:d.vector(d.u8())}),$l=d.enum("PackageUpgradeError",{UnableToFetchPackage:d.struct("UnableToFetchPackage",{packageId:z}),NotAPackage:d.struct("NotAPackage",{objectId:z}),IncompatibleUpgrade:null,DigestDoesNotMatch:d.struct("DigestDoesNotMatch",{digest:d.vector(d.u8())}),UnknownUpgradePolicy:d.struct("UnknownUpgradePolicy",{policy:d.u8()}),PackageIDDoesNotMatch:d.struct("PackageIDDoesNotMatch",{packageId:z,ticketId:z})}),Ol=d.struct("ModuleId",{address:z,name:d.string()}),qi=d.struct("MoveLocation",{module:Ol,function:d.u16(),instruction:d.u16(),functionName:d.option(d.string())}),xl=d.enum("CommandArgumentError",{TypeMismatch:null,InvalidBCSBytes:null,InvalidUsageOfPureArg:null,InvalidArgumentToPrivateEntryFunction:null,IndexOutOfBounds:d.struct("IndexOutOfBounds",{idx:d.u16()}),SecondaryIndexOutOfBounds:d.struct("SecondaryIndexOutOfBounds",{resultIdx:d.u16(),secondaryIdx:d.u16()}),InvalidResultArity:d.struct("InvalidResultArity",{resultIdx:d.u16()}),InvalidGasCoinUsage:null,InvalidValueUsage:null,InvalidObjectByValue:null,InvalidObjectByMutRef:null,SharedObjectOperationNotAllowed:null}),Ml=d.enum("TypeArgumentError",{TypeNotFound:null,ConstraintNotSatisfied:null}),Al=d.enum("ExecutionFailureStatus",{InsufficientGas:null,InvalidGasObject:null,InvariantViolation:null,FeatureNotYetSupported:null,MoveObjectTooBig:d.struct("MoveObjectTooBig",{objectSize:d.u64(),maxObjectSize:d.u64()}),MovePackageTooBig:d.struct("MovePackageTooBig",{objectSize:d.u64(),maxObjectSize:d.u64()}),CircularObjectOwnership:d.struct("CircularObjectOwnership",{object:z}),InsufficientCoinBalance:null,CoinBalanceOverflow:null,PublishErrorNonZeroAddress:null,SuiMoveVerificationError:null,MovePrimitiveRuntimeError:d.option(qi),MoveAbort:d.tuple([qi,d.u64()]),VMVerificationOrDeserializationError:null,VMInvariantViolation:null,FunctionNotFound:null,ArityMismatch:null,TypeArityMismatch:null,NonEntryFunctionInvoked:null,CommandArgumentError:d.struct("CommandArgumentError",{argIdx:d.u16(),kind:xl}),TypeArgumentError:d.struct("TypeArgumentError",{argumentIdx:d.u16(),kind:Ml}),UnusedValueWithoutDrop:d.struct("UnusedValueWithoutDrop",{resultIdx:d.u16(),secondaryIdx:d.u16()}),InvalidPublicFunctionReturnType:d.struct("InvalidPublicFunctionReturnType",{idx:d.u16()}),InvalidTransferObject:null,EffectsTooLarge:d.struct("EffectsTooLarge",{currentSize:d.u64(),maxSize:d.u64()}),PublishUpgradeMissingDependency:null,PublishUpgradeDependencyDowngrade:null,PackageUpgradeError:d.struct("PackageUpgradeError",{upgradeError:$l}),WrittenObjectsTooLarge:d.struct("WrittenObjectsTooLarge",{currentSize:d.u64(),maxSize:d.u64()}),CertificateDenied:null,SuiMoveVerificationTimedout:null,SharedObjectOperationNotAllowed:null,InputObjectDeleted:null,ExecutionCancelledDueToSharedObjectCongestion:d.struct("ExecutionCancelledDueToSharedObjectCongestion",{congestedObjects:d.vector(z)}),AddressDeniedForCoin:d.struct("AddressDeniedForCoin",{address:z,coinType:d.string()}),CoinTypeGlobalPause:d.struct("CoinTypeGlobalPause",{coinType:d.string()}),ExecutionCancelledDueToRandomnessUnavailable:null}),No=d.enum("ExecutionStatus",{Success:null,Failed:d.struct("ExecutionFailed",{error:Al,command:d.option(d.u64())})}),Do=d.struct("GasCostSummary",{computationCost:d.u64(),storageCost:d.u64(),storageRebate:d.u64(),nonRefundableStorageFee:d.u64()}),Bl=d.struct("TransactionEffectsV1",{status:No,executedEpoch:d.u64(),gasUsed:Do,modifiedAtVersions:d.vector(d.tuple([z,d.u64()])),sharedObjects:d.vector(ke),transactionDigest:We,created:d.vector(d.tuple([ke,Rt])),mutated:d.vector(d.tuple([ke,Rt])),unwrapped:d.vector(d.tuple([ke,Rt])),deleted:d.vector(ke),unwrappedThenDeleted:d.vector(ke),wrapped:d.vector(ke),gasObject:d.tuple([ke,Rt]),eventsDigest:d.option(We),dependencies:d.vector(We)}),di=d.tuple([d.u64(),We]),Cl=d.enum("ObjectIn",{NotExist:null,Exist:d.tuple([di,Rt])}),jl=d.enum("ObjectOut",{NotExist:null,ObjectWrite:d.tuple([We,Rt]),PackageWrite:di}),Pl=d.enum("IDOperation",{None:null,Created:null,Deleted:null}),Ul=d.struct("EffectsObjectChange",{inputState:Cl,outputState:jl,idOperation:Pl}),Rl=d.enum("UnchangedSharedKind",{ReadOnlyRoot:di,MutateDeleted:d.u64(),ReadDeleted:d.u64(),Cancelled:d.u64(),PerEpochConfig:null}),Nl=d.struct("TransactionEffectsV2",{status:No,executedEpoch:d.u64(),gasUsed:Do,transactionDigest:We,gasObjectIndex:d.option(d.u32()),eventsDigest:d.option(We),dependencies:d.vector(We),lamportVersion:d.u64(),changedObjects:d.vector(d.tuple([z,Ul])),unchangedSharedObjects:d.vector(d.tuple([z,Rl])),auxDataDigest:d.option(We)}),Dl=d.enum("TransactionEffects",{V1:Bl,V2:Nl});function on(t){switch(t){case"u8":return d.u8();case"u16":return d.u16();case"u32":return d.u32();case"u64":return d.u64();case"u128":return d.u128();case"u256":return d.u256();case"bool":return d.bool();case"string":return d.string();case"id":case"address":return z}const e=t.match(/^(vector|option)<(.+)>$/);if(e){const[n,r]=e.slice(1);return n==="vector"?d.vector(on(r)):d.option(on(r))}throw new Error(`Invalid Pure type name: ${t}`)}const f={...d,U8:d.u8(),U16:d.u16(),U32:d.u32(),U64:d.u64(),U128:d.u128(),U256:d.u256(),ULEB128:d.uleb128(),Bool:d.bool(),String:d.string(),Address:z,AppId:Mo,Argument:He,CallArg:yo,Command:vo,CompressedSignature:Co,GasData:Io,Intent:Ao,IntentMessage:Bo,IntentScope:Oo,IntentVersion:xo,MultiSig:kl,MultiSigPkMap:Po,MultiSigPublicKey:Uo,ObjectArg:bo,ObjectDigest:We,Owner:Rt,PasskeyAuthenticator:Tl,ProgrammableMoveCall:wo,ProgrammableTransaction:_o,PublicKey:jo,SenderSignedData:Il,SenderSignedTransaction:Ro,SharedObjectRef:mo,StructTag:Eo,SuiObjectRef:ke,TransactionData:$o,TransactionDataV1:To,TransactionEffects:Dl,TransactionExpiration:ko,TransactionKind:So,TypeTag:li};function zo(t,e,n){const r=f.Address.serialize(t).toBytes(),s=f.TypeTag.serialize(e).toBytes(),i=f.u64().serialize(n.length).toBytes(),a=go.create({dkLen:32});return a.update(new Uint8Array([240])),a.update(r),a.update(i),a.update(n),a.update(s),`0x${hn(a.digest().slice(0,32))}`}const zl="object",Vl="ID",Wl="ascii",Fl="String",Ll="string",Gl="String",Hl="option",ql="Option";function Kl(t){const e=typeof t.body=="object"&&"datatype"in t.body?t.body.datatype:null;return!!e&&C(e.package)===C("0x2")&&e.module==="tx_context"&&e.type==="TxContext"}function As(t){if(typeof t=="string")switch(t){case"address":return f.Address;case"bool":return f.Bool;case"u8":return f.U8;case"u16":return f.U16;case"u32":return f.U32;case"u64":return f.U64;case"u128":return f.U128;case"u256":return f.U256;default:throw new Error(`Unknown type signature ${t}`)}if("vector"in t){if(t.vector==="u8")return f.vector(f.U8).transform({input:n=>typeof n=="string"?new TextEncoder().encode(n):n,output:n=>n});const e=As(t.vector);return e?f.vector(e):null}if("datatype"in t){const e=C(t.datatype.package);if(e===C(rl)){if(t.datatype.module===Wl&&t.datatype.type===Fl||t.datatype.module===Ll&&t.datatype.type===Gl)return f.String;if(t.datatype.module===Hl&&t.datatype.type===ql){const n=As(t.datatype.typeParameters[0]);return n?f.vector(n):null}}if(e===C(to)&&t.datatype.module===zl&&t.datatype.type===Vl)return f.Address}return null}function Ql(t){return typeof t=="object"&&"Reference"in t?{ref:"&",body:Bn(t.Reference)}:typeof t=="object"&&"MutableReference"in t?{ref:"&mut",body:Bn(t.MutableReference)}:{ref:null,body:Bn(t)}}function Bn(t){if(typeof t=="string")switch(t){case"Address":return"address";case"Bool":return"bool";case"U8":return"u8";case"U16":return"u16";case"U32":return"u32";case"U64":return"u64";case"U128":return"u128";case"U256":return"u256";default:throw new Error(`Unexpected type ${t}`)}if("Vector"in t)return{vector:Bn(t.Vector)};if("Struct"in t)return{datatype:{package:t.Struct.address,module:t.Struct.module,type:t.Struct.name,typeParameters:t.Struct.typeArguments.map(Bn)}};if("TypeParameter"in t)return{typeParameter:t.TypeParameter};throw new Error(`Unexpected type ${JSON.stringify(t)}`)}function Jl(t){return{$kind:"Pure",Pure:{bytes:t instanceof Uint8Array?X(t):t.toBase64()}}}const oe={Pure:Jl,ObjectRef({objectId:t,digest:e,version:n}){return{$kind:"Object",Object:{$kind:"ImmOrOwnedObject",ImmOrOwnedObject:{digest:e,version:n,objectId:C(t)}}}},SharedObjectRef({objectId:t,mutable:e,initialSharedVersion:n}){return{$kind:"Object",Object:{$kind:"SharedObject",SharedObject:{mutable:e,initialSharedVersion:n,objectId:C(t)}}}},ReceivingRef({objectId:t,digest:e,version:n}){return{$kind:"Object",Object:{$kind:"Receiving",Receiving:{digest:e,version:n,objectId:C(t)}}}}};var Xl=/^[\da-f]{8}(?:-[\da-f]{4}){3}-[\da-f]{12}$/iu,ls;function Vo(t){return{lang:t?.lang??ls?.lang,message:t?.message,abortEarly:t?.abortEarly??ls?.abortEarly,abortPipeEarly:t?.abortPipeEarly??ls?.abortPipeEarly}}var Yl;function Zl(t){return Yl?.get(t)}var ed;function td(t){return ed?.get(t)}var nd;function rd(t,e){return nd?.get(t)?.get(e)}function Wo(t){const e=typeof t;return e==="string"?`"${t}"`:e==="number"||e==="bigint"||e==="boolean"?`${t}`:e==="object"||e==="function"?(t&&Object.getPrototypeOf(t)?.constructor?.name)??"null":e}function se(t,e,n,r,s){const i=s&&"input"in s?s.input:n.value,a=s?.expected??t.expects??null,o=s?.received??Wo(i),c={kind:t.kind,type:t.type,input:i,expected:a,received:o,message:`Invalid ${e}: ${a?`Expected ${a} but r`:"R"}eceived ${o}`,requirement:t.requirement,path:s?.path,issues:s?.issues,lang:r.lang,abortEarly:r.abortEarly,abortPipeEarly:r.abortPipeEarly},l=t.kind==="schema",u=s?.message??t.message??rd(t.reference,c.lang)??(l?td(c.lang):null)??r.message??Zl(c.lang);u&&(c.message=typeof u=="function"?u(c):u),l&&(n.typed=!1),n.issues?n.issues.push(c):n.issues=[c]}function sd(t,e){return Object.hasOwn(t,e)&&e!=="__proto__"&&e!=="prototype"&&e!=="constructor"}var id=class extends Error{issues;constructor(t){super(t[0].message),this.name="ValiError",this.issues=t}};function qn(t,e){return{kind:"validation",type:"check",reference:qn,async:!1,expects:null,requirement:t,message:e,_run(n,r){return n.typed&&!this.requirement(n.value)&&se(this,"input",n,r),n}}}function L(t){return{kind:"validation",type:"integer",reference:L,async:!1,expects:null,requirement:Number.isInteger,message:t,_run(e,n){return e.typed&&!this.requirement(e.value)&&se(this,"integer",e,n),e}}}function Jr(t){return{kind:"transformation",type:"transform",reference:Jr,async:!1,operation:t,_run(e){return e.value=this.operation(e.value),e}}}function ad(t){return{kind:"validation",type:"uuid",reference:ad,async:!1,expects:null,requirement:Xl,message:t,_run(e,n){return e.typed&&!this.requirement.test(e.value)&&se(this,"UUID",e,n),e}}}function hi(t,e,n){return typeof t.default=="function"?t.default(e,n):t.default}function Cr(t,e){return!t._run({typed:!1,value:e},{abortEarly:!0}).issues}function O(t,e){return{kind:"schema",type:"array",reference:O,expects:"Array",async:!1,item:t,message:e,_run(n,r){const s=n.value;if(Array.isArray(s)){n.typed=!0,n.value=[];for(let i=0;i<s.length;i++){const a=s[i],o=this.item._run({typed:!1,value:a},r);if(o.issues){const c={type:"array",origin:"value",input:s,key:i,value:a};for(const l of o.issues)l.path?l.path.unshift(c):l.path=[c],n.issues?.push(l);if(n.issues||(n.issues=o.issues),r.abortEarly){n.typed=!1;break}}o.typed||(n.typed=!1),n.value.push(o.value)}}else se(this,"type",n,r);return n}}}function Xr(t){return{kind:"schema",type:"bigint",reference:Xr,expects:"bigint",async:!1,message:t,_run(e,n){return typeof e.value=="bigint"?e.typed=!0:se(this,"type",e,n),e}}}function Yr(t){return{kind:"schema",type:"boolean",reference:Yr,expects:"boolean",async:!1,message:t,_run(e,n){return typeof e.value=="boolean"?e.typed=!0:se(this,"type",e,n),e}}}function Wn(t){return{kind:"schema",type:"lazy",reference:Wn,expects:"unknown",async:!1,getter:t,_run(e,n){return this.getter(e.value)._run(e,n)}}}function x(t,e){return{kind:"schema",type:"literal",reference:x,expects:Wo(t),async:!1,literal:t,message:e,_run(n,r){return n.value===this.literal?n.typed=!0:se(this,"type",n,r),n}}}function P(t,...e){const n={kind:"schema",type:"nullable",reference:P,expects:`${t.expects} | null`,async:!1,wrapped:t,_run(r,s){return r.value===null&&("default"in this&&(r.value=hi(this,r,s)),r.value===null)?(r.typed=!0,r):this.wrapped._run(r,s)}};return 0 in e&&(n.default=e[0]),n}function pn(t,...e){const n={kind:"schema",type:"nullish",reference:pn,expects:`${t.expects} | null | undefined`,async:!1,wrapped:t,_run(r,s){return(r.value===null||r.value===void 0)&&("default"in this&&(r.value=hi(this,r,s)),r.value===null||r.value===void 0)?(r.typed=!0,r):this.wrapped._run(r,s)}};return 0 in e&&(n.default=e[0]),n}function F(t){return{kind:"schema",type:"number",reference:F,expects:"number",async:!1,message:t,_run(e,n){return typeof e.value=="number"&&!isNaN(e.value)?e.typed=!0:se(this,"type",e,n),e}}}function v(t,e){return{kind:"schema",type:"object",reference:v,expects:"Object",async:!1,entries:t,message:e,_run(n,r){const s=n.value;if(s&&typeof s=="object"){n.typed=!0,n.value={};for(const i in this.entries){const a=s[i],o=this.entries[i]._run({typed:!1,value:a},r);if(o.issues){const c={type:"object",origin:"value",input:s,key:i,value:a};for(const l of o.issues)l.path?l.path.unshift(c):l.path=[c],n.issues?.push(l);if(n.issues||(n.issues=o.issues),r.abortEarly){n.typed=!1;break}}o.typed||(n.typed=!1),(o.value!==void 0||i in s)&&(n.value[i]=o.value)}}else se(this,"type",n,r);return n}}}function Y(t,...e){const n={kind:"schema",type:"optional",reference:Y,expects:`${t.expects} | undefined`,async:!1,wrapped:t,_run(r,s){return r.value===void 0&&("default"in this&&(r.value=hi(this,r,s)),r.value===void 0)?(r.typed=!0,r):this.wrapped._run(r,s)}};return 0 in e&&(n.default=e[0]),n}function Fn(t,e,n){return{kind:"schema",type:"record",reference:Fn,expects:"Object",async:!1,key:t,value:e,message:n,_run(r,s){const i=r.value;if(i&&typeof i=="object"){r.typed=!0,r.value={};for(const a in i)if(sd(i,a)){const o=i[a],c=this.key._run({typed:!1,value:a},s);if(c.issues){const u={type:"object",origin:"key",input:i,key:a,value:o};for(const h of c.issues)h.path=[u],r.issues?.push(h);if(r.issues||(r.issues=c.issues),s.abortEarly){r.typed=!1;break}}const l=this.value._run({typed:!1,value:o},s);if(l.issues){const u={type:"object",origin:"value",input:i,key:a,value:o};for(const h of l.issues)h.path?h.path.unshift(u):h.path=[u],r.issues?.push(h);if(r.issues||(r.issues=l.issues),s.abortEarly){r.typed=!1;break}}(!c.typed||!l.typed)&&(r.typed=!1),c.typed&&(r.value[c.value]=l.value)}}else se(this,"type",r,s);return r}}}function M(t){return{kind:"schema",type:"string",reference:M,expects:"string",async:!1,message:t,_run(e,n){return typeof e.value=="string"?e.typed=!0:se(this,"type",e,n),e}}}function fi(t,e){return{kind:"schema",type:"tuple",reference:fi,expects:"Array",async:!1,items:t,message:e,_run(n,r){const s=n.value;if(Array.isArray(s)){n.typed=!0,n.value=[];for(let i=0;i<this.items.length;i++){const a=s[i],o=this.items[i]._run({typed:!1,value:a},r);if(o.issues){const c={type:"array",origin:"value",input:s,key:i,value:a};for(const l of o.issues)l.path?l.path.unshift(c):l.path=[c],n.issues?.push(l);if(n.issues||(n.issues=o.issues),r.abortEarly){n.typed=!1;break}}o.typed||(n.typed=!1),n.value.push(o.value)}}else se(this,"type",n,r);return n}}}function Ki(t){let e;if(t)for(const n of t)e?e.push(...n.issues):e=n.issues;return e}function Z(t,e){return{kind:"schema",type:"union",reference:Z,expects:[...new Set(t.map(n=>n.expects))].join(" | ")||"never",async:!1,options:t,message:e,_run(n,r){let s,i,a;for(const o of this.options){const c=o._run({typed:!1,value:n.value},r);if(c.typed)if(c.issues)i?i.push(c):i=[c];else{s=c;break}else a?a.push(c):a=[c]}if(s)return s;if(i){if(i.length===1)return i[0];se(this,"type",n,r,{issues:Ki(i)}),n.typed=!0}else{if(a?.length===1)return a[0];se(this,"type",n,r,{issues:Ki(a)})}return n}}}function Ht(){return{kind:"schema",type:"unknown",reference:Ht,expects:"unknown",async:!1,_run(t){return t.typed=!0,t}}}function Fo(t,e,n=new Set){for(const r of e)r.type==="variant"?Fo(t,r.options,n):n.add(r.entries[t].expects);return n}function od(t,e,n){let r;return{kind:"schema",type:"variant",reference:od,expects:"Object",async:!1,key:t,options:e,message:n,_run(s,i){const a=s.value;if(a&&typeof a=="object"){const o=a[this.key];if(this.key in a){let c;for(const l of this.options)if(l.type==="variant"||!l.entries[this.key]._run({typed:!1,value:o},i).issues){const u=l._run({typed:!1,value:a},i);if(!u.issues)return u;(!c||!c.typed&&u.typed)&&(c=u)}if(c)return c}r||(r=[...Fo(this.key,this.options)].join(" | ")||"never"),se(this,"type",s,i,{input:o,expected:r,path:[{type:"object",origin:"value",input:a,key:this.key,value:o}]})}else se(this,"type",s,i);return s}}}function W(t,e,n){const r=t._run({typed:!1,value:e},Vo(n));if(r.issues)throw new id(r.issues);return r.value}function R(...t){return{...t[0],pipe:t,_run(e,n){for(let r=0;r<t.length;r++){if(e.issues&&(t[r].kind==="schema"||t[r].kind==="transformation")){e.typed=!1;break}(!e.issues||!n.abortEarly&&!n.abortPipeEarly)&&(e=t[r]._run(e,n))}return e}}}function Eg(t,e,n){const r=t._run({typed:!1,value:e},Vo(n));return{typed:r.typed,success:!r.issues,output:r.value,issues:r.issues}}function Qt(t){const e=Object.entries(t).map(([n,r])=>v({[n]:r}));return R(Z(e),Jr(n=>({...n,$kind:Object.keys(n)[0]})))}const mn=R(M(),Jr(t=>C(t)),qn(Ne)),we=mn,qt=M(),pe=R(Z([M(),R(F(),L())]),qn(t=>{try{return BigInt(t),BigInt(t)>=0&&BigInt(t)<=18446744073709551615n}catch{return!1}},"Invalid u64")),$t=v({objectId:mn,version:pe,digest:M()}),D=R(Z([v({GasCoin:x(!0)}),v({Input:R(F(),L()),type:Y(x("pure"))}),v({Input:R(F(),L()),type:Y(x("object"))}),v({Result:R(F(),L())}),v({NestedResult:fi([R(F(),L()),R(F(),L())])})]),Jr(t=>({...t,$kind:Object.keys(t)[0]}))),cd=v({budget:P(pe),price:P(pe),owner:P(mn),payment:P(O($t))}),Bs=Z([x("address"),x("bool"),x("u8"),x("u16"),x("u32"),x("u64"),x("u128"),x("u256"),v({vector:Wn(()=>Bs)}),v({datatype:v({package:M(),module:M(),type:M(),typeParameters:O(Wn(()=>Bs))})}),v({typeParameter:R(F(),L())})]),ud=v({ref:P(Z([x("&"),x("&mut")])),body:Bs}),ld=v({package:we,module:M(),function:M(),typeArguments:O(M()),arguments:O(D),_argumentTypes:Y(P(O(ud)))}),dd=v({name:M(),inputs:Fn(M(),Z([D,O(D)])),data:Fn(M(),Ht())}),hd=Qt({MoveCall:ld,TransferObjects:v({objects:O(D),address:D}),SplitCoins:v({coin:D,amounts:O(D)}),MergeCoins:v({destination:D,sources:O(D)}),Publish:v({modules:O(qt),dependencies:O(we)}),MakeMoveVec:v({type:P(M()),elements:O(D)}),Upgrade:v({modules:O(qt),dependencies:O(we),package:we,ticket:D}),$Intent:dd}),Lo=Qt({ImmOrOwnedObject:$t,SharedObject:v({objectId:we,initialSharedVersion:pe,mutable:Yr()}),Receiving:$t}),fd=Qt({Object:Lo,Pure:v({bytes:qt}),UnresolvedPure:v({value:Ht()}),UnresolvedObject:v({objectId:we,version:Y(P(pe)),digest:Y(P(M())),initialSharedVersion:Y(P(pe))})}),Qi=Qt({Object:Lo,Pure:v({bytes:qt})}),Go=Qt({None:x(!0),Epoch:pe}),ur=v({version:x(2),sender:pn(mn),expiration:pn(Go),gasData:cd,inputs:O(fd),commands:O(hd)}),Ue={MoveCall(t){const[e,n="",r=""]="target"in t?t.target.split("::"):[t.package,t.module,t.function];return{$kind:"MoveCall",MoveCall:{package:e,module:n,function:r,typeArguments:t.typeArguments??[],arguments:t.arguments??[]}}},TransferObjects(t,e){return{$kind:"TransferObjects",TransferObjects:{objects:t.map(n=>W(D,n)),address:W(D,e)}}},SplitCoins(t,e){return{$kind:"SplitCoins",SplitCoins:{coin:W(D,t),amounts:e.map(n=>W(D,n))}}},MergeCoins(t,e){return{$kind:"MergeCoins",MergeCoins:{destination:W(D,t),sources:e.map(n=>W(D,n))}}},Publish({modules:t,dependencies:e}){return{$kind:"Publish",Publish:{modules:t.map(n=>typeof n=="string"?n:X(new Uint8Array(n))),dependencies:e.map(n=>ct(n))}}},Upgrade({modules:t,dependencies:e,package:n,ticket:r}){return{$kind:"Upgrade",Upgrade:{modules:t.map(s=>typeof s=="string"?s:X(new Uint8Array(s))),dependencies:e.map(s=>ct(s)),package:n,ticket:W(D,r)}}},MakeMoveVec({type:t,elements:e}){return{$kind:"MakeMoveVec",MakeMoveVec:{type:t??null,elements:e.map(n=>W(D,n))}}},Intent({name:t,inputs:e={},data:n={}}){return{$kind:"$Intent",$Intent:{name:t,inputs:Object.fromEntries(Object.entries(e).map(([r,s])=>[r,Array.isArray(s)?s.map(i=>W(D,i)):W(D,s)])),data:n}}}},Cs=v({digest:M(),objectId:M(),version:Z([R(F(),L()),M(),Xr()])}),pd=Qt({ImmOrOwned:Cs,Shared:v({objectId:we,initialSharedVersion:pe,mutable:Yr()}),Receiving:Cs}),Ji=Qt({Object:pd,Pure:O(R(F(),L()))}),Ho=Z([v({kind:x("Input"),index:R(F(),L()),value:Ht(),type:Y(x("object"))}),v({kind:x("Input"),index:R(F(),L()),value:Ht(),type:x("pure")})]),gd=Z([v({Epoch:R(F(),L())}),v({None:P(x(!0))})]),Xi=R(Z([F(),M(),Xr()]),qn(t=>{if(!["string","number","bigint"].includes(typeof t))return!1;try{return BigInt(t),!0}catch{return!1}})),pi=Z([v({bool:P(x(!0))}),v({u8:P(x(!0))}),v({u64:P(x(!0))}),v({u128:P(x(!0))}),v({address:P(x(!0))}),v({signer:P(x(!0))}),v({vector:Wn(()=>pi)}),v({struct:Wn(()=>md)}),v({u16:P(x(!0))}),v({u32:P(x(!0))}),v({u256:P(x(!0))})]),md=v({address:M(),module:M(),name:M(),typeParams:O(pi)}),bd=v({budget:Y(Xi),price:Y(Xi),payment:Y(O(Cs)),owner:Y(M())}),yd=[Ho,v({kind:x("GasCoin")}),v({kind:x("Result"),index:R(F(),L())}),v({kind:x("NestedResult"),index:R(F(),L()),resultIndex:R(F(),L())})],lt=Z([...yd]),wd=v({kind:x("MoveCall"),target:R(M(),qn(t=>t.split("::").length===3)),typeArguments:O(M()),arguments:O(lt)}),vd=v({kind:x("TransferObjects"),objects:O(lt),address:lt}),_d=v({kind:x("SplitCoins"),coin:lt,amounts:O(lt)}),Sd=v({kind:x("MergeCoins"),destination:lt,sources:O(lt)}),kd=v({kind:x("MakeMoveVec"),type:Z([v({Some:pi}),v({None:P(x(!0))})]),objects:O(lt)}),Ed=v({kind:x("Publish"),modules:O(O(R(F(),L()))),dependencies:O(M())}),Id=v({kind:x("Upgrade"),modules:O(O(R(F(),L()))),dependencies:O(M()),packageId:M(),ticket:lt}),Td=[wd,vd,_d,Sd,Ed,Id,kd],$d=Z([...Td]);v({version:x(1),sender:Y(M()),expiration:pn(gd),gasConfig:bd,inputs:O(Ho),transactions:O($d)});function Yi(t){const e=t.inputs.map((n,r)=>{if(n.Object)return{kind:"Input",index:r,value:{Object:n.Object.ImmOrOwnedObject?{ImmOrOwned:n.Object.ImmOrOwnedObject}:n.Object.Receiving?{Receiving:{digest:n.Object.Receiving.digest,version:n.Object.Receiving.version,objectId:n.Object.Receiving.objectId}}:{Shared:{mutable:n.Object.SharedObject.mutable,initialSharedVersion:n.Object.SharedObject.initialSharedVersion,objectId:n.Object.SharedObject.objectId}}},type:"object"};if(n.Pure)return{kind:"Input",index:r,value:{Pure:Array.from(Q(n.Pure.bytes))},type:"pure"};if(n.UnresolvedPure)return{kind:"Input",type:"pure",index:r,value:n.UnresolvedPure.value};if(n.UnresolvedObject)return{kind:"Input",type:"object",index:r,value:n.UnresolvedObject.objectId};throw new Error("Invalid input")});return{version:1,sender:t.sender??void 0,expiration:t.expiration?.$kind==="Epoch"?{Epoch:Number(t.expiration.Epoch)}:t.expiration?{None:!0}:null,gasConfig:{owner:t.gasData.owner??void 0,budget:t.gasData.budget??void 0,price:t.gasData.price??void 0,payment:t.gasData.payment??void 0},inputs:e,transactions:t.commands.map(n=>{if(n.MakeMoveVec)return{kind:"MakeMoveVec",type:n.MakeMoveVec.type===null?{None:!0}:{Some:Ie.parseFromStr(n.MakeMoveVec.type)},objects:n.MakeMoveVec.elements.map(r=>et(r,e))};if(n.MergeCoins)return{kind:"MergeCoins",destination:et(n.MergeCoins.destination,e),sources:n.MergeCoins.sources.map(r=>et(r,e))};if(n.MoveCall)return{kind:"MoveCall",target:`${n.MoveCall.package}::${n.MoveCall.module}::${n.MoveCall.function}`,typeArguments:n.MoveCall.typeArguments,arguments:n.MoveCall.arguments.map(r=>et(r,e))};if(n.Publish)return{kind:"Publish",modules:n.Publish.modules.map(r=>Array.from(Q(r))),dependencies:n.Publish.dependencies};if(n.SplitCoins)return{kind:"SplitCoins",coin:et(n.SplitCoins.coin,e),amounts:n.SplitCoins.amounts.map(r=>et(r,e))};if(n.TransferObjects)return{kind:"TransferObjects",objects:n.TransferObjects.objects.map(r=>et(r,e)),address:et(n.TransferObjects.address,e)};if(n.Upgrade)return{kind:"Upgrade",modules:n.Upgrade.modules.map(r=>Array.from(Q(r))),dependencies:n.Upgrade.dependencies,packageId:n.Upgrade.package,ticket:et(n.Upgrade.ticket,e)};throw new Error(`Unknown transaction ${Object.keys(n)}`)})}}function et(t,e){if(t.$kind==="GasCoin")return{kind:"GasCoin"};if(t.$kind==="Result")return{kind:"Result",index:t.Result};if(t.$kind==="NestedResult")return{kind:"NestedResult",index:t.NestedResult[0],resultIndex:t.NestedResult[1]};if(t.$kind==="Input")return e[t.Input];throw new Error(`Invalid argument ${Object.keys(t)}`)}function Od(t){return W(ur,{version:2,sender:t.sender??null,expiration:t.expiration?"Epoch"in t.expiration?{Epoch:t.expiration.Epoch}:{None:!0}:null,gasData:{owner:t.gasConfig.owner??null,budget:t.gasConfig.budget?.toString()??null,price:t.gasConfig.price?.toString()??null,payment:t.gasConfig.payment?.map(e=>({digest:e.digest,objectId:e.objectId,version:e.version.toString()}))??null},inputs:t.inputs.map(e=>{if(e.kind==="Input"){if(Cr(Ji,e.value)){const n=W(Ji,e.value);if(n.Object){if(n.Object.ImmOrOwned)return{Object:{ImmOrOwnedObject:{objectId:n.Object.ImmOrOwned.objectId,version:String(n.Object.ImmOrOwned.version),digest:n.Object.ImmOrOwned.digest}}};if(n.Object.Shared)return{Object:{SharedObject:{mutable:n.Object.Shared.mutable??null,initialSharedVersion:n.Object.Shared.initialSharedVersion,objectId:n.Object.Shared.objectId}}};if(n.Object.Receiving)return{Object:{Receiving:{digest:n.Object.Receiving.digest,version:String(n.Object.Receiving.version),objectId:n.Object.Receiving.objectId}}};throw new Error("Invalid object input")}return{Pure:{bytes:X(new Uint8Array(n.Pure))}}}return e.type==="object"?{UnresolvedObject:{objectId:e.value}}:{UnresolvedPure:{value:e.value}}}throw new Error("Invalid input")}),commands:t.transactions.map(e=>{switch(e.kind){case"MakeMoveVec":return{MakeMoveVec:{type:"Some"in e.type?Ie.tagToString(e.type.Some):null,elements:e.objects.map(n=>tt(n))}};case"MergeCoins":return{MergeCoins:{destination:tt(e.destination),sources:e.sources.map(n=>tt(n))}};case"MoveCall":{const[n,r,s]=e.target.split("::");return{MoveCall:{package:n,module:r,function:s,typeArguments:e.typeArguments,arguments:e.arguments.map(i=>tt(i))}}}case"Publish":return{Publish:{modules:e.modules.map(n=>X(Uint8Array.from(n))),dependencies:e.dependencies}};case"SplitCoins":return{SplitCoins:{coin:tt(e.coin),amounts:e.amounts.map(n=>tt(n))}};case"TransferObjects":return{TransferObjects:{objects:e.objects.map(n=>tt(n)),address:tt(e.address)}};case"Upgrade":return{Upgrade:{modules:e.modules.map(n=>X(Uint8Array.from(n))),dependencies:e.dependencies,package:e.packageId,ticket:tt(e.ticket)}}}throw new Error(`Unknown transaction ${Object.keys(e)}`)})})}function tt(t){switch(t.kind){case"GasCoin":return{GasCoin:!0};case"Result":return{Result:t.index};case"NestedResult":return{NestedResult:[t.index,t.resultIndex]};case"Input":return{Input:t.index}}}function Kn(t){return Z(Object.entries(t).map(([e,n])=>v({[e]:n})))}const je=Kn({GasCoin:x(!0),Input:R(F(),L()),Result:R(F(),L()),NestedResult:fi([R(F(),L()),R(F(),L())])}),xd=v({budget:P(pe),price:P(pe),owner:P(mn),payment:P(O($t))}),Md=v({package:we,module:M(),function:M(),typeArguments:O(M()),arguments:O(je)}),Ad=v({name:M(),inputs:Fn(M(),Z([je,O(je)])),data:Fn(M(),Ht())}),Bd=Kn({MoveCall:Md,TransferObjects:v({objects:O(je),address:je}),SplitCoins:v({coin:je,amounts:O(je)}),MergeCoins:v({destination:je,sources:O(je)}),Publish:v({modules:O(qt),dependencies:O(we)}),MakeMoveVec:v({type:P(M()),elements:O(je)}),Upgrade:v({modules:O(qt),dependencies:O(we),package:we,ticket:je}),$Intent:Ad}),Cd=Kn({ImmOrOwnedObject:$t,SharedObject:v({objectId:we,initialSharedVersion:pe,mutable:Yr()}),Receiving:$t}),jd=Kn({Object:Cd,Pure:v({bytes:qt}),UnresolvedPure:v({value:Ht()}),UnresolvedObject:v({objectId:we,version:Y(P(pe)),digest:Y(P(M())),initialSharedVersion:Y(P(pe))})}),Pd=Kn({None:x(!0),Epoch:pe}),Ud=v({version:x(2),sender:pn(mn),expiration:pn(Pd),gasData:xd,inputs:O(jd),commands:O(Bd),digest:Y(P(M()))}),Rd=50,Nd=1000n,Dd=5e10;function qo(t){return async function(n,r,s){return await Ld(n,t),await Fd(n,t),r.onlyTransactionKind||(await zd(n,t),await Vd(n,t),await Wd(n,t)),await s()}}async function zd(t,e){t.gasConfig.price||(t.gasConfig.price=String(await e.getReferenceGasPrice()))}async function Vd(t,e){if(t.gasConfig.budget)return;const n=await e.dryRunTransactionBlock({transactionBlock:t.build({overrides:{gasData:{budget:String(Dd),payment:[]}}})});if(n.effects.status.status!=="success")throw new Error(`Dry run failed, could not automatically determine a budget: ${n.effects.status.error}`,{cause:n});const r=Nd*BigInt(t.gasConfig.price||1n),s=BigInt(n.effects.gasUsed.computationCost)+r,i=s+BigInt(n.effects.gasUsed.storageCost)-BigInt(n.effects.gasUsed.storageRebate);t.gasConfig.budget=String(i>s?i:s)}async function Wd(t,e){if(!t.gasConfig.payment){const r=(await e.getCoins({owner:t.gasConfig.owner||t.sender,coinType:sl})).data.filter(s=>!t.inputs.find(a=>a.Object?.ImmOrOwnedObject?s.coinObjectId===a.Object.ImmOrOwnedObject.objectId:!1)).map(s=>({objectId:s.coinObjectId,digest:s.digest,version:s.version}));if(!r.length)throw new Error("No valid gas coins found for the transaction.");t.gasConfig.payment=r.map(s=>W($t,s))}}async function Fd(t,e){const n=t.inputs.filter(u=>u.UnresolvedObject&&!(u.UnresolvedObject.version||u.UnresolvedObject?.initialSharedVersion)),r=[...new Set(n.map(u=>ct(u.UnresolvedObject.objectId)))],s=r.length?fn(r,Rd):[],i=(await Promise.all(s.map(u=>e.multiGetObjects({ids:u,options:{showOwner:!0}})))).flat(),a=new Map(r.map((u,h)=>[u,i[h]])),o=Array.from(a).filter(([u,h])=>h.error).map(([u,h])=>JSON.stringify(h.error));if(o.length)throw new Error(`The following input objects are invalid: ${o.join(", ")}`);const c=i.map(u=>{if(u.error||!u.data)throw new Error(`Failed to fetch object: ${u.error}`);const h=u.data.owner,g=h&&typeof h=="object"?"Shared"in h?h.Shared.initial_shared_version:"ConsensusAddressOwner"in h?h.ConsensusAddressOwner.start_version:null:null;return{objectId:u.data.objectId,digest:u.data.digest,version:u.data.version,initialSharedVersion:g}}),l=new Map(r.map((u,h)=>[u,c[h]]));for(const[u,h]of t.inputs.entries()){if(!h.UnresolvedObject)continue;let g;const p=C(h.UnresolvedObject.objectId),m=l.get(p);h.UnresolvedObject.initialSharedVersion??m?.initialSharedVersion?g=oe.SharedObjectRef({objectId:p,initialSharedVersion:h.UnresolvedObject.initialSharedVersion||m?.initialSharedVersion,mutable:Gd(t,u)}):Hd(t,u)&&(g=oe.ReceivingRef({objectId:p,digest:h.UnresolvedObject.digest??m?.digest,version:h.UnresolvedObject.version??m?.version})),t.inputs[t.inputs.indexOf(h)]=g??oe.ObjectRef({objectId:p,digest:h.UnresolvedObject.digest??m?.digest,version:h.UnresolvedObject.version??m?.version})}}async function Ld(t,e){const{inputs:n,commands:r}=t,s=[],i=new Set;r.forEach(o=>{if(o.MoveCall){if(o.MoveCall._argumentTypes)return;if(o.MoveCall.arguments.map(u=>u.$kind==="Input"?t.inputs[u.Input]:null).some(u=>u?.UnresolvedPure||u?.UnresolvedObject)){const u=`${o.MoveCall.package}::${o.MoveCall.module}::${o.MoveCall.function}`;i.add(u),s.push(o.MoveCall)}}});const a=new Map;i.size>0&&await Promise.all([...i].map(async o=>{const[c,l,u]=o.split("::"),h=await e.getNormalizedMoveFunction({package:c,module:l,function:u});a.set(o,h.parameters.map(g=>Ql(g)))})),s.length&&await Promise.all(s.map(async o=>{const c=a.get(`${o.package}::${o.module}::${o.function}`);if(!c)return;const u=c.length>0&&Kl(c.at(-1))?c.slice(0,c.length-1):c;o._argumentTypes=u})),r.forEach(o=>{if(!o.MoveCall)return;const c=o.MoveCall,l=`${c.package}::${c.module}::${c.function}`,u=c._argumentTypes;if(u){if(u.length!==o.MoveCall.arguments.length)throw new Error(`Incorrect number of arguments for ${l}`);u.forEach((h,g)=>{const p=c.arguments[g];if(p.$kind!=="Input")return;const m=n[p.Input];if(!m.UnresolvedPure&&!m.UnresolvedObject)return;const b=m.UnresolvedPure?.value??m.UnresolvedObject?.objectId,y=As(h.body);if(y){p.type="pure",n[n.indexOf(m)]=oe.Pure(y.serialize(b));return}if(typeof b!="string")throw new Error(`Expect the argument to be an object id string, got ${JSON.stringify(b,null,2)}`);p.type="object";const k=m.UnresolvedPure?{$kind:"UnresolvedObject",UnresolvedObject:{objectId:b}}:m;n[p.Input]=k})}})}function Gd(t,e){let n=!1;return t.getInputUses(e,(r,s)=>{if(s.MoveCall&&s.MoveCall._argumentTypes){const i=s.MoveCall.arguments.indexOf(r);n=s.MoveCall._argumentTypes[i].ref!=="&"||n}(s.$kind==="MakeMoveVec"||s.$kind==="MergeCoins"||s.$kind==="SplitCoins"||s.$kind==="TransferObjects")&&(n=!0)}),n}function Hd(t,e){let n=!1;return t.getInputUses(e,(r,s)=>{if(s.MoveCall&&s.MoveCall._argumentTypes){const i=s.MoveCall.arguments.indexOf(r);n=qd(s.MoveCall._argumentTypes[i])||n}}),n}function qd(t){return typeof t.body!="object"||!("datatype"in t.body)?!1:t.body.datatype.package==="0x2"&&t.body.datatype.module==="transfer"&&t.body.datatype.type==="Receiving"}function Ko(t,e){return!!(t.inputs.some(n=>n.UnresolvedObject||n.UnresolvedPure)||!e.onlyTransactionKind&&(!t.gasConfig.price||!t.gasConfig.budget||!t.gasConfig.payment))}async function Kd(t,e,n){if(Qd(t),!Ko(t,e))return await Zi(t),n();const r=Qo(e);return(r.core?.resolveTransactionPlugin()??qo(r))(t,e,async()=>{await Zi(t),await n()})}function Zi(t){t.inputs.forEach((e,n)=>{if(e.$kind!=="Object"&&e.$kind!=="Pure")throw new Error(`Input at index ${n} has not been resolved.  Expected a Pure or Object input, but found ${JSON.stringify(e)}`)})}function Qo(t){if(!t.client)throw new Error("No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.");return t.client}function Qd(t){for(const e of t.commands)switch(e.$kind){case"SplitCoins":e.SplitCoins.amounts.forEach(n=>{ea(n,f.U64,t)});break;case"TransferObjects":ea(e.TransferObjects.address,f.Address,t);break}}function ea(t,e,n){if(t.$kind!=="Input")return;const r=n.inputs[t.Input];r.$kind==="UnresolvedPure"&&(n.inputs[t.Input]=oe.Pure(e.serialize(r.UnresolvedPure.value)))}function Jd(t){function e(n){return t(n)}return e.system=n=>{const r=n?.mutable;return e(r!==void 0?oe.SharedObjectRef({objectId:"0x5",initialSharedVersion:1,mutable:r}):{$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x5",initialSharedVersion:1}})},e.clock=()=>e(oe.SharedObjectRef({objectId:"0x6",initialSharedVersion:1,mutable:!1})),e.random=()=>e(oe.SharedObjectRef({objectId:"0x8",initialSharedVersion:1,mutable:!1})),e.denyList=n=>{const r=n?.mutable;return e(r!==void 0?oe.SharedObjectRef({objectId:"0x403",initialSharedVersion:1,mutable:r}):{$kind:"UnresolvedObject",UnresolvedObject:{objectId:"0x403",initialSharedVersion:1}})},e.option=({type:n,value:r})=>s=>s.moveCall({typeArguments:[n],target:`0x1::option::${r===null?"none":"some"}`,arguments:r===null?[]:[s.object(r)]}),e}function Xd(t){function e(n,r){if(typeof n=="string")return t(on(n).serialize(r));if(n instanceof Uint8Array||ci(n))return t(n);throw new Error("tx.pure must be called either a bcs type name, or a serialized bcs value")}return e.u8=n=>t(f.U8.serialize(n)),e.u16=n=>t(f.U16.serialize(n)),e.u32=n=>t(f.U32.serialize(n)),e.u64=n=>t(f.U64.serialize(n)),e.u128=n=>t(f.U128.serialize(n)),e.u256=n=>t(f.U256.serialize(n)),e.bool=n=>t(f.Bool.serialize(n)),e.string=n=>t(f.String.serialize(n)),e.address=n=>t(f.Address.serialize(n)),e.id=e.address,e.vector=(n,r)=>t(f.vector(on(n)).serialize(r)),e.option=(n,r)=>t(f.option(on(n)).serialize(r)),e}function Yd(t,e){const n=Array.from(`${t}::`).map(s=>s.charCodeAt(0)),r=new Uint8Array(n.length+e.length);return r.set(n),r.set(e,n.length),go(r,{dkLen:32})}function ta(t){return C(t).replace("0x","")}class de{constructor(e){this.version=2,this.sender=e?.sender??null,this.expiration=e?.expiration??null,this.inputs=e?.inputs??[],this.commands=e?.commands??[],this.gasData=e?.gasData??{budget:null,price:null,owner:null,payment:null}}static fromKindBytes(e){const r=f.TransactionKind.parse(e).ProgrammableTransaction;if(!r)throw new Error("Unable to deserialize from bytes.");return de.restore({version:2,sender:null,expiration:null,gasData:{budget:null,owner:null,payment:null,price:null},inputs:r.inputs,commands:r.commands})}static fromBytes(e){const r=f.TransactionData.parse(e)?.V1,s=r.kind.ProgrammableTransaction;if(!r||!s)throw new Error("Unable to deserialize from bytes.");return de.restore({version:2,sender:r.sender,expiration:r.expiration,gasData:r.gasData,inputs:s.inputs,commands:s.commands})}static restore(e){return e.version===2?new de(W(ur,e)):new de(W(ur,Od(e)))}static getDigestFromBytes(e){const n=Yd("TransactionData",e);return Kr(n)}get gasConfig(){return this.gasData}set gasConfig(e){this.gasData=e}build({maxSizeBytes:e=1/0,overrides:n,onlyTransactionKind:r}={}){const s=this.inputs,i=this.commands,a={ProgrammableTransaction:{inputs:s,commands:i}};if(r)return f.TransactionKind.serialize(a,{maxSize:e}).toBytes();const o=n?.expiration??this.expiration,c=n?.sender??this.sender,l={...this.gasData,...n?.gasConfig,...n?.gasData};if(!c)throw new Error("Missing transaction sender");if(!l.budget)throw new Error("Missing gas budget");if(!l.payment)throw new Error("Missing gas payment");if(!l.price)throw new Error("Missing gas price");const u={sender:ta(c),expiration:o||{None:!0},gasData:{payment:l.payment,owner:ta(this.gasData.owner??c),price:BigInt(l.price),budget:BigInt(l.budget)},kind:{ProgrammableTransaction:{inputs:s,commands:i}}};return f.TransactionData.serialize({V1:u},{maxSize:e}).toBytes()}addInput(e,n){const r=this.inputs.length;return this.inputs.push(n),{Input:r,type:e,$kind:"Input"}}getInputUses(e,n){this.mapArguments((r,s)=>(r.$kind==="Input"&&r.Input===e&&n(r,s),r))}mapCommandArguments(e,n){const r=this.commands[e];switch(r.$kind){case"MoveCall":r.MoveCall.arguments=r.MoveCall.arguments.map(i=>n(i,r,e));break;case"TransferObjects":r.TransferObjects.objects=r.TransferObjects.objects.map(i=>n(i,r,e)),r.TransferObjects.address=n(r.TransferObjects.address,r,e);break;case"SplitCoins":r.SplitCoins.coin=n(r.SplitCoins.coin,r,e),r.SplitCoins.amounts=r.SplitCoins.amounts.map(i=>n(i,r,e));break;case"MergeCoins":r.MergeCoins.destination=n(r.MergeCoins.destination,r,e),r.MergeCoins.sources=r.MergeCoins.sources.map(i=>n(i,r,e));break;case"MakeMoveVec":r.MakeMoveVec.elements=r.MakeMoveVec.elements.map(i=>n(i,r,e));break;case"Upgrade":r.Upgrade.ticket=n(r.Upgrade.ticket,r,e);break;case"$Intent":const s=r.$Intent.inputs;r.$Intent.inputs={};for(const[i,a]of Object.entries(s))r.$Intent.inputs[i]=Array.isArray(a)?a.map(o=>n(o,r,e)):n(a,r,e);break;case"Publish":break;default:throw new Error(`Unexpected transaction kind: ${r.$kind}`)}}mapArguments(e){for(const n of this.commands.keys())this.mapCommandArguments(n,e)}replaceCommand(e,n,r=e){if(!Array.isArray(n)){this.commands[e]=n;return}const s=n.length-1;this.commands.splice(e,1,...n),s!==0&&this.mapArguments((i,a,o)=>{if(o<e+n.length)return i;switch(i.$kind){case"Result":i.Result===e&&(i.Result=r),i.Result>e&&(i.Result+=s);break;case"NestedResult":i.NestedResult[0]===e&&(i.NestedResult[0]=r),i.NestedResult[0]>e&&(i.NestedResult[0]+=s);break}return i})}getDigest(){const e=this.build({onlyTransactionKind:!1});return de.getDigestFromBytes(e)}snapshot(){return W(ur,this)}shallowClone(){return new de({version:this.version,sender:this.sender,expiration:this.expiration,gasData:{...this.gasData},inputs:[...this.inputs],commands:[...this.commands]})}}function na(t){if(typeof t=="string")return C(t);if(t.Object)return t.Object.ImmOrOwnedObject?C(t.Object.ImmOrOwnedObject.objectId):t.Object.Receiving?C(t.Object.Receiving.objectId):C(t.Object.SharedObject.objectId);if(t.UnresolvedObject)return C(t.UnresolvedObject.objectId)}function Zd(t){return Cr(D,t)}var Jo=t=>{throw TypeError(t)},Xo=(t,e,n)=>e.has(t)||Jo("Cannot "+n),ee=(t,e,n)=>(Xo(t,e,"read from private field"),e.get(t)),ra=(t,e,n)=>e.has(t)?Jo("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),sa=(t,e,n,r)=>(Xo(t,e,"write to private field"),e.set(t,n),n),Bt,ie;const eh=class Yo{constructor({prefix:e,cache:n}={}){ra(this,Bt),ra(this,ie),sa(this,Bt,e??[]),sa(this,ie,n??new Map)}read(e,n){const r=[ee(this,Bt),...e].join(":");if(ee(this,ie).has(r))return ee(this,ie).get(r);const s=n();return ee(this,ie).set(r,s),typeof s=="object"&&s!==null&&"then"in s?Promise.resolve(s).then(i=>(ee(this,ie).set(r,i),i)).catch(i=>{throw ee(this,ie).delete(r),i}):s}readSync(e,n){const r=[ee(this,Bt),...e].join(":");if(ee(this,ie).has(r))return ee(this,ie).get(r);const s=n();return ee(this,ie).set(r,s),s}clear(e){const n=[...ee(this,Bt),...e??[]].join(":");if(!n){ee(this,ie).clear();return}for(const r of ee(this,ie).keys())r.startsWith(n)&&ee(this,ie).delete(r)}scope(e){return new Yo({prefix:[...ee(this,Bt),...Array.isArray(e)?e:[e]],cache:ee(this,ie)})}};Bt=new WeakMap;ie=new WeakMap;let Zr=eh;const Zo="1.37.3",th="1.55.0";var ec=t=>{throw TypeError(t)},gi=(t,e,n)=>e.has(t)||ec("Cannot "+n),K=(t,e,n)=>(gi(t,e,"read from private field"),n?n.call(t):e.get(t)),vn=(t,e,n)=>e.has(t)?ec("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),Yn=(t,e,n,r)=>(gi(t,e,"write to private field"),e.set(t,n),n),es=(t,e,n)=>(gi(t,e,"access private method"),n),Ln,dt,Gn,kt,Ke,js,Ps,tc,nc,mi;const nh="/",rh={"Mvr-Source":`@mysten/sui@${Zo}`};class sh{constructor({cache:e,url:n,pageSize:r=50,overrides:s}){vn(this,Ke),vn(this,Ln),vn(this,dt),vn(this,Gn),vn(this,kt),Yn(this,Ln,e),Yn(this,dt,n),Yn(this,Gn,r),Yn(this,kt,{packages:s?.packages,types:s?.types}),ih(K(this,kt))}async resolvePackage({package:e}){return{package:await K(this,Ke,js).load(e)}}async resolveType({type:e}){const n=[...Us(e)],r=await K(this,Ke,Ps).loadMany(n),s={};for(let i=0;i<n.length;i++){const a=r[i];if(a instanceof Error)throw a;s[n[i]]=a}return{type:Rs(e,s)}}async resolve({types:e=[],packages:n=[]}){const r=new Set;for(const u of e??[])Us(u,r);const s=[...r],[i,a]=await Promise.all([s.length>0?K(this,Ke,Ps).loadMany(s):[],n.length>0?K(this,Ke,js).loadMany(n):[]]),o={...K(this,kt)?.types};for(const[u,h]of s.entries()){const g=i[u];if(g instanceof Error)throw g;o[h]=g}const c={};for(const u of e??[]){const h=Rs(u,o);c[u]={type:h}}const l={};for(const[u,h]of(n??[]).entries()){const g=K(this,kt)?.packages?.[h]??a[u];if(g instanceof Error)throw g;l[h]={package:g}}return{types:c,packages:l}}}Ln=new WeakMap;dt=new WeakMap;Gn=new WeakMap;kt=new WeakMap;Ke=new WeakSet;js=function(){return K(this,Ln).readSync(["#mvrPackageDataLoader",K(this,dt)??""],()=>{const t=new Wa(async n=>{if(!K(this,dt))throw new Error(`MVR Api URL is not set for the current client (resolving ${n.join(", ")})`);const r=await es(this,Ke,tc).call(this,n);return n.map(s=>r[s]??new Error(`Failed to resolve package: ${s}`))}),e=K(this,kt)?.packages;if(e)for(const[n,r]of Object.entries(e))t.prime(n,r);return t})};Ps=function(){return K(this,Ln).readSync(["#mvrTypeDataLoader",K(this,dt)??""],()=>{const t=new Wa(async n=>{if(!K(this,dt))throw new Error(`MVR Api URL is not set for the current client (resolving ${n.join(", ")})`);const r=await es(this,Ke,nc).call(this,n);return n.map(s=>r[s]??new Error(`Failed to resolve type: ${s}`))}),e=K(this,kt)?.types;if(e)for(const[n,r]of Object.entries(e))t.prime(n,r);return t})};tc=async function(t){if(t.length===0)return{};const e=fn(t,K(this,Gn)),n={};return await Promise.all(e.map(async r=>{const s=await es(this,Ke,mi).call(this,"/v1/resolution/bulk",{names:r});if(s?.resolution)for(const i of Object.keys(s?.resolution)){const a=s.resolution[i]?.package_id;a&&(n[i]=a)}})),n};nc=async function(t){if(t.length===0)return{};const e=fn(t,K(this,Gn)),n={};return await Promise.all(e.map(async r=>{const s=await es(this,Ke,mi).call(this,"/v1/struct-definition/bulk",{types:r});if(s?.resolution)for(const i of Object.keys(s?.resolution)){const a=s.resolution[i]?.type_tag;a&&(n[i]=a)}})),n};mi=async function(t,e){if(!K(this,dt))throw new Error("MVR Api URL is not set for the current client");const n=await fetch(`${K(this,dt)}${t}`,{method:"POST",headers:{"Content-Type":"application/json",...rh},body:JSON.stringify(e)});if(!n.ok){const r=await n.json().catch(()=>({}));throw new Error(`Failed to resolve types: ${r?.message}`)}return n.json()};function ih(t){if(t?.packages)for(const[e,n]of Object.entries(t.packages)){if(!be(e))throw new Error(`Invalid package name: ${e}`);if(!Ne(C(n)))throw new Error(`Invalid package ID: ${n}`)}if(t?.types)for(const[e,n]of Object.entries(t.types)){if(ut(e).typeParams.length>0)throw new Error("Type overrides must be first-level only. If you want to supply generic types, just pass each type individually.");const r=ut(n);if(!Ne(r.address))throw new Error(`Invalid type: ${n}`)}}function Us(t,e=new Set){if(typeof t=="string"&&!he(t))return e;const n=rc(t)?t:ut(t);he(n.address)&&e.add(`${n.address}::${n.module}::${n.name}`);for(const r of n.typeParams)Us(r,e);return e}function Rs(t,e){const n=rc(t)?t:ut(t),r=`${n.address}::${n.module}::${n.name}`,s=e[r];return Gt({...n,address:s?s.split("::")[0]:n.address,typeParams:n.typeParams.map(i=>Rs(i,e))})}function he(t){return t.includes(nh)||t.includes("@")||t.includes(".sui")}function rc(t){return typeof t=="object"&&"address"in t&&"module"in t&&"name"in t&&"typeParams"in t}function ah(t){const e=new Set,n=new Set;for(const r of t.commands)switch(r.$kind){case"MakeMoveVec":r.MakeMoveVec.type&&ia([r.MakeMoveVec.type]).forEach(a=>{n.add(a)});break;case"MoveCall":const s=r.MoveCall,i=s.package.split("::")[0];if(he(i)){if(!be(i))throw new Error(`Invalid package name: ${i}`);e.add(i)}ia(s.typeArguments??[]).forEach(a=>{n.add(a)});break}return{packages:[...e],types:[...n]}}function oh(t,e){for(const n of t.commands){if(n.MakeMoveVec?.type){if(!he(n.MakeMoveVec.type))continue;if(!e.types[n.MakeMoveVec.type])throw new Error(`No resolution found for type: ${n.MakeMoveVec.type}`);n.MakeMoveVec.type=e.types[n.MakeMoveVec.type].type}const r=n.MoveCall;if(!r)continue;const s=r.package.split("::"),i=s[0];if(he(i)&&!e.packages[i])throw new Error(`No address found for package: ${i}`);he(i)&&(s[0]=e.packages[i].package,r.package=s.join("::"));const a=r.typeArguments;if(a){for(let o=0;o<a.length;o++)if(he(a[o])){if(!e.types[a[o]])throw new Error(`No resolution found for type: ${a[o]}`);a[o]=e.types[a[o]].type}r.typeArguments=a}}}function ia(t){const e=new Set;for(const n of t)if(he(n)){if(!Yu(n))throw new Error(`Invalid type with names: ${n}`);e.add(n)}return e}const ch=t=>async(e,n,r)=>{const s=ah(e);if(s.types.length===0&&s.packages.length===0)return r();const i=await uh(n).core.mvr.resolve({types:s.types,packages:s.packages});oh(e,i),await r()};function uh(t){if(!t.client)throw new Error("No sui client passed to Transaction#build, but transaction data was not sufficient to build offline.");return t.client}var sc=t=>{throw TypeError(t)},bi=(t,e,n)=>e.has(t)||sc("Cannot "+n),w=(t,e,n)=>(bi(t,e,"read from private field"),n?n.call(t):e.get(t)),Ge=(t,e,n)=>e.has(t)?sc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),N=(t,e,n,r)=>(bi(t,e,"write to private field"),e.set(t,n),n),q=(t,e,n)=>(bi(t,e,"access private method"),n),Nt,Ft,at,Qe,Te,$e,Ve,Et,E,G,ic,lr,dr,hr,jr,Ns,yi,ac,oc;function ds(t,e=1/0){const n={$kind:"Result",get Result(){return typeof t=="function"?t():t}},r=[],s=i=>r[i]??(r[i]={$kind:"NestedResult",get NestedResult(){return[typeof t=="function"?t():t,i]}});return new Proxy(n,{set(){throw new Error("The transaction result is a proxy, and does not support setting properties directly")},get(i,a){if(a in i)return Reflect.get(i,a);if(a===Symbol.iterator)return function*(){let c=0;for(;c<e;)yield s(c),c++};if(typeof a=="symbol")return;const o=parseInt(a,10);if(!(Number.isNaN(o)||o<0))return s(o)}})}const cc=Symbol.for("@mysten/transaction");function uc(t){return!!t&&typeof t=="object"&&t[cc]===!0}const aa={buildPlugins:new Map,serializationPlugins:new Map},hs=Symbol.for("@mysten/transaction/registry");function _n(){try{const t=globalThis;return t[hs]||(t[hs]=aa),t[hs]}catch{return aa}}const lc=class Ds{constructor(){Ge(this,G),Ge(this,Nt),Ge(this,Ft),Ge(this,at,new Map),Ge(this,Qe,[]),Ge(this,Te,[]),Ge(this,$e,new Set),Ge(this,Ve,new Set),Ge(this,Et,new Map),Ge(this,E),this.object=Jd(n=>{if(typeof n=="function")return this.object(this.add(n));if(typeof n=="object"&&Cr(D,n))return n;const r=na(n),s=w(this,E).inputs.find(i=>r===na(i));return s?.Object?.SharedObject&&typeof n=="object"&&n.Object?.SharedObject&&(s.Object.SharedObject.mutable=s.Object.SharedObject.mutable||n.Object.SharedObject.mutable),s?{$kind:"Input",Input:w(this,E).inputs.indexOf(s),type:"object"}:q(this,G,dr).call(this,"object",typeof n=="string"?{$kind:"UnresolvedObject",UnresolvedObject:{objectId:C(n)}}:n)});const e=_n();N(this,E,new de),N(this,Ft,[...e.buildPlugins.values()]),N(this,Nt,[...e.serializationPlugins.values()])}static fromKind(e){const n=new Ds;return N(n,E,de.fromKindBytes(typeof e=="string"?Q(e):e)),N(n,Qe,w(n,E).inputs.slice()),N(n,Te,w(n,E).commands.slice()),N(n,$e,new Set(w(n,Te).map((r,s)=>s))),n}static from(e){const n=new Ds;return uc(e)?N(n,E,new de(e.getData())):typeof e!="string"||!e.startsWith("{")?N(n,E,de.fromBytes(typeof e=="string"?Q(e):e)):N(n,E,de.restore(JSON.parse(e))),N(n,Qe,w(n,E).inputs.slice()),N(n,Te,w(n,E).commands.slice()),N(n,$e,new Set(w(n,Te).map((r,s)=>s))),n}static registerGlobalSerializationPlugin(e,n){_n().serializationPlugins.set(e,n??e)}static unregisterGlobalSerializationPlugin(e){_n().serializationPlugins.delete(e)}static registerGlobalBuildPlugin(e,n){_n().buildPlugins.set(e,n??e)}static unregisterGlobalBuildPlugin(e){_n().buildPlugins.delete(e)}addSerializationPlugin(e){w(this,Nt).push(e)}addBuildPlugin(e){w(this,Ft).push(e)}addIntentResolver(e,n){if(w(this,at).has(e)&&w(this,at).get(e)!==n)throw new Error(`Intent resolver for ${e} already exists`);w(this,at).set(e,n)}setSender(e){w(this,E).sender=e}setSenderIfNotSet(e){w(this,E).sender||(w(this,E).sender=e)}setExpiration(e){w(this,E).expiration=e?W(Go,e):null}setGasPrice(e){w(this,E).gasConfig.price=String(e)}setGasBudget(e){w(this,E).gasConfig.budget=String(e)}setGasBudgetIfNotSet(e){w(this,E).gasData.budget==null&&(w(this,E).gasConfig.budget=String(e))}setGasOwner(e){w(this,E).gasConfig.owner=e}setGasPayment(e){w(this,E).gasConfig.payment=e.map(n=>W($t,n))}get blockData(){return Yi(w(this,E).snapshot())}getData(){return w(this,E).snapshot()}get[cc](){return!0}get pure(){return Object.defineProperty(this,"pure",{enumerable:!1,value:Xd(e=>ci(e)?q(this,G,dr).call(this,"pure",{$kind:"Pure",Pure:{bytes:e.toBase64()}}):q(this,G,dr).call(this,"pure",Cr(Qi,e)?W(Qi,e):e instanceof Uint8Array?oe.Pure(e):{$kind:"UnresolvedPure",UnresolvedPure:{value:e}}))}),this.pure}get gas(){return{$kind:"GasCoin",GasCoin:!0}}objectRef(...e){return this.object(oe.ObjectRef(...e))}receivingRef(...e){return this.object(oe.ReceivingRef(...e))}sharedObjectRef(...e){return this.object(oe.SharedObjectRef(...e))}add(e){if(typeof e=="function"){if(w(this,Et).has(e))return w(this,Et).get(e);const n=q(this,G,ic).call(this),r=e(n);if(!(r&&typeof r=="object"&&"then"in r))return N(this,$e,w(n,$e)),w(this,Et).set(e,r),r;const s=q(this,G,lr).call(this,{$kind:"$Intent",$Intent:{name:"AsyncTransactionThunk",inputs:{},data:{resultIndex:w(this,E).commands.length,result:null}}});w(this,Ve).add(Promise.resolve(r).then(a=>{s.$Intent.data.result=a}));const i=ds(()=>s.$Intent.data.resultIndex);return w(this,Et).set(e,i),i}else q(this,G,lr).call(this,e);return ds(w(this,E).commands.length-1)}splitCoins(e,n){const r=Ue.SplitCoins(typeof e=="string"?this.object(e):q(this,G,jr).call(this,e),n.map(s=>typeof s=="number"||typeof s=="bigint"||typeof s=="string"?this.pure.u64(s):q(this,G,hr).call(this,s)));return q(this,G,lr).call(this,r),ds(w(this,E).commands.length-1,n.length)}mergeCoins(e,n){return this.add(Ue.MergeCoins(this.object(e),n.map(r=>this.object(r))))}publish({modules:e,dependencies:n}){return this.add(Ue.Publish({modules:e,dependencies:n}))}upgrade({modules:e,dependencies:n,package:r,ticket:s}){return this.add(Ue.Upgrade({modules:e,dependencies:n,package:r,ticket:this.object(s)}))}moveCall({arguments:e,...n}){return this.add(Ue.MoveCall({...n,arguments:e?.map(r=>q(this,G,hr).call(this,r))}))}transferObjects(e,n){return this.add(Ue.TransferObjects(e.map(r=>this.object(r)),typeof n=="string"?this.pure.address(n):q(this,G,hr).call(this,n)))}makeMoveVec({type:e,elements:n}){return this.add(Ue.MakeMoveVec({type:e,elements:n.map(r=>this.object(r))}))}serialize(){return JSON.stringify(Yi(w(this,E).snapshot()))}async toJSON(e={}){await this.prepareForSerialization(e);const n=this.isFullyResolved();return JSON.stringify(W(Ud,n?{...w(this,E).snapshot(),digest:w(this,E).getDigest()}:w(this,E).snapshot()),(r,s)=>typeof s=="bigint"?s.toString():s,2)}async sign(e){const{signer:n,...r}=e,s=await this.build(r);return n.signTransaction(s)}isFullyResolved(){return!(!w(this,E).sender||w(this,Ve).size>0||w(this,E).commands.some(e=>e.$Intent)||Ko(w(this,E),{}))}async build(e={}){return await this.prepareForSerialization(e),await q(this,G,Ns).call(this,e),w(this,E).build({onlyTransactionKind:e.onlyTransactionKind})}async getDigest(e={}){return await this.prepareForSerialization(e),await q(this,G,Ns).call(this,e),w(this,E).getDigest()}async prepareForSerialization(e){await q(this,G,ac).call(this),q(this,G,oc).call(this);const n=new Set;for(const s of w(this,E).commands)s.$Intent&&n.add(s.$Intent.name);const r=[...w(this,Nt)];for(const s of n)if(!e.supportedIntents?.includes(s)){if(!w(this,at).has(s))throw new Error(`Missing intent resolver for ${s}`);r.push(w(this,at).get(s))}r.push(ch()),await q(this,G,yi).call(this,r,e)}};Nt=new WeakMap;Ft=new WeakMap;at=new WeakMap;Qe=new WeakMap;Te=new WeakMap;$e=new WeakMap;Ve=new WeakMap;Et=new WeakMap;E=new WeakMap;G=new WeakSet;ic=function(){const t=new lc;return N(t,E,w(this,E)),N(t,Nt,w(this,Nt)),N(t,Ft,w(this,Ft)),N(t,at,w(this,at)),N(t,Ve,w(this,Ve)),N(t,$e,new Set(w(this,$e))),N(t,Et,w(this,Et)),w(this,Qe).push(w(t,Qe)),w(this,Te).push(w(t,Te)),t};lr=function(t){const e=w(this,E).commands.length;return w(this,Te).push(t),w(this,$e).add(e),w(this,E).commands.push(t),w(this,E).mapCommandArguments(e,n=>{if(n.$kind==="Result"&&!w(this,$e).has(n.Result))throw new Error(`Result { Result: ${n.Result} } is not available to use the current transaction`);if(n.$kind==="NestedResult"&&!w(this,$e).has(n.NestedResult[0]))throw new Error(`Result { NestedResult: [${n.NestedResult[0]}, ${n.NestedResult[1]}] } is not available to use the current transaction`);if(n.$kind==="Input"&&n.Input>=w(this,E).inputs.length)throw new Error(`Input { Input: ${n.Input} } references an input that does not exist in the current transaction`);return n}),t};dr=function(t,e){return w(this,Qe).push(e),w(this,E).addInput(t,e)};hr=function(t){return ci(t)?this.pure(t):q(this,G,jr).call(this,t)};jr=function(t){if(typeof t=="function"){const e=this.add(t);return typeof e=="function"?q(this,G,jr).call(this,e):W(D,e)}return W(D,t)};Ns=async function(t){if(!t.onlyTransactionKind&&!w(this,E).sender)throw new Error("Missing transaction sender");await q(this,G,yi).call(this,[...w(this,Ft),Kd],t)};yi=async function(t,e){const n=r=>{if(r>=t.length)return()=>{};const s=t[r];return async()=>{const i=n(r+1);let a=!1,o=!1;if(await s(w(this,E),e,async()=>{if(a)throw new Error(`next() was call multiple times in TransactionPlugin ${r}`);a=!0,await i(),o=!0}),!a)throw new Error(`next() was not called in TransactionPlugin ${r}`);if(!o)throw new Error(`next() was not awaited in TransactionPlugin ${r}`)}};await n(0)(),N(this,Qe,w(this,E).inputs.slice()),N(this,Te,w(this,E).commands.slice())};ac=async function(){for(;w(this,Ve).size>0;){const t=Promise.all(w(this,Ve));w(this,Ve).clear(),w(this,Ve).add(t),await t,w(this,Ve).delete(t)}};oc=function(){const t=w(this,E).commands,e=w(this,E).inputs,n=w(this,Te).flat(1/0),r=w(this,Qe).flat(1/0);if(n.length!==t.length)throw new Error("Unexpected number of commands found in transaction data");if(r.length!==e.length)throw new Error("Unexpected number of inputs found in transaction data");const s=n.filter(a=>a.$Intent?.name!=="AsyncTransactionThunk");w(this,E).commands=s,w(this,E).inputs=r,N(this,Te,s),N(this,Qe,r),N(this,$e,new Set(s.map((a,o)=>o)));function i(a){const o=t[a];if(o.$Intent?.name==="AsyncTransactionThunk"){const l=o.$Intent.data.result;if(l==null)throw new Error("AsyncTransactionThunk has not been resolved");return i(l.Result)}const c=s.indexOf(o);if(c===-1)throw new Error("Unable to find original index for command");return c}w(this,E).mapArguments(a=>{if(a.$kind==="Input"){const o=r.indexOf(e[a.Input]);if(o===-1)throw new Error("Input has not been resolved");return{...a,Input:o}}else if(a.$kind==="Result"){const o=i(a.Result);return{...a,Result:o}}else if(a.$kind==="NestedResult"){const o=i(a.NestedResult[0]);return{...a,NestedResult:[o,a.NestedResult[1]]}}return a});for(const[a,o]of t.entries())if(o.$Intent?.name==="AsyncTransactionThunk")try{o.$Intent.data.resultIndex=i(a)}catch{}};let Ae=lc;const Pr="CoinWithBalance",oa=Gt("0x2::sui::SUI");function dc({type:t=oa,balance:e,useGasCoin:n=!0}){let r=null;return s=>{if(r)return r;s.addIntentResolver(Pr,dh);const i=t==="gas"?t:Gt(t);return r=s.add(Ue.Intent({name:Pr,inputs:{},data:{type:i===oa&&n?"gas":i,balance:BigInt(e)}})),r}}const lh=v({type:M(),balance:Xr()});async function dh(t,e,n){const r=new Set,s=new Map;if(!t.sender)throw new Error("Sender must be set to resolve CoinWithBalance");for(const l of t.commands)if(l.$kind==="$Intent"&&l.$Intent.name===Pr){const{type:u,balance:h}=W(lh,l.$Intent.data);u!=="gas"&&h>0n&&r.add(u),s.set(u,(s.get(u)??0n)+h)}const i=new Set;for(const l of t.inputs)l.Object?.ImmOrOwnedObject&&i.add(l.Object.ImmOrOwnedObject.objectId),l.UnresolvedObject?.objectId&&i.add(l.UnresolvedObject.objectId);const a=new Map,o=fh(e);await Promise.all([...r].map(async l=>{a.set(l,await hh({coinType:l,balance:s.get(l),client:o,owner:t.sender,usedIds:i}))}));const c=new Map;c.set("gas",{$kind:"GasCoin",GasCoin:!0});for(const[l,u]of t.commands.entries()){if(u.$kind!=="$Intent"||u.$Intent.name!==Pr)continue;const{type:h,balance:g}=u.$Intent.data;if(g===0n&&h!=="gas"){t.replaceCommand(l,Ue.MoveCall({target:"0x2::coin::zero",typeArguments:[h]}));continue}const p=[];if(!c.has(h)){const[m,...b]=a.get(h).map(y=>t.addInput("object",oe.ObjectRef({objectId:y.coinObjectId,digest:y.digest,version:y.version})));b.length>0&&p.push(Ue.MergeCoins(m,b)),c.set(h,m)}p.push(Ue.SplitCoins(c.get(h),[t.addInput("pure",oe.Pure(f.u64().serialize(g)))])),t.replaceCommand(l,p),t.mapArguments(m=>m.$kind==="Result"&&m.Result===l?{$kind:"NestedResult",NestedResult:[l+p.length-1,0]}:m)}return n()}async function hh({coinType:t,balance:e,client:n,owner:r,usedIds:s}){let i=e;const a=[];return o();async function o(c=null){const{data:l,hasNextPage:u,nextCursor:h}=await n.getCoins({owner:r,coinType:t,cursor:c}),g=l.sort((p,m)=>Number(BigInt(m.balance)-BigInt(p.balance)));for(const p of g){if(s.has(p.coinObjectId))continue;const m=BigInt(p.balance);if(a.push(p),i-=m,i<=0)return a}if(u)return o(h);throw new Error(`Not enough coins of type ${t} to satisfy requested balance`)}}function fh(t){const e=Qo(t);if(!e.jsonRpc)throw new Error("CoinWithBalance intent currently only works with SuiClient");return e}const ph={"-32700":"ParseError","-32701":"OversizedRequest","-32702":"OversizedResponse","-32600":"InvalidRequest","-32601":"MethodNotFound","-32602":"InvalidParams","-32603":"InternalError","-32604":"ServerBusy","-32000":"CallExecutionFailed","-32001":"UnknownError","-32003":"SubscriptionClosed","-32004":"SubscriptionClosedWithError","-32005":"BatchesNotSupported","-32006":"TooManySubscriptions","-32050":"TransientError","-32002":"TransactionExecutionClientError"};class hc extends Error{}class fc extends hc{constructor(e,n){super(e),this.code=n,this.type=ph[n]??"ServerError"}}class gh extends hc{constructor(e,n,r){super(e),this.status=n,this.statusText=r}}var pc=t=>{throw TypeError(t)},wi=(t,e,n)=>e.has(t)||pc("Cannot "+n),V=(t,e,n)=>(wi(t,e,"read from private field"),n?n.call(t):e.get(t)),Mt=(t,e,n)=>e.has(t)?pc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),cn=(t,e,n,r)=>(wi(t,e,"write to private field"),e.set(t,n),n),gc=(t,e,n)=>(wi(t,e,"access private method"),n),mh=(t,e,n,r)=>({set _(s){cn(t,e,s)},get _(){return V(t,e,r)}}),yt,Cn,ot,Dt,Hn,zt,Ur,mc,bc;function bh(t){const e=new URL(t);return e.protocol=e.protocol.replace("http","ws"),e.toString()}const yh={WebSocketConstructor:typeof WebSocket<"u"?WebSocket:void 0,callTimeout:3e4,reconnectTimeout:3e3,maxReconnects:5};class wh{constructor(e,n={}){if(Mt(this,Ur),Mt(this,yt,0),Mt(this,Cn,0),Mt(this,ot,null),Mt(this,Dt,null),Mt(this,Hn,new Set),Mt(this,zt,new Map),this.endpoint=e,this.options={...yh,...n},!this.options.WebSocketConstructor)throw new Error("Missing WebSocket constructor");this.endpoint.startsWith("http")&&(this.endpoint=bh(this.endpoint))}async makeRequest(e,n,r){const s=await gc(this,Ur,mc).call(this);return new Promise((i,a)=>{cn(this,yt,V(this,yt)+1),V(this,zt).set(V(this,yt),{resolve:i,reject:a,timeout:setTimeout(()=>{V(this,zt).delete(V(this,yt)),a(new Error(`Request timeout: ${e}`))},this.options.callTimeout)}),r?.addEventListener("abort",()=>{V(this,zt).delete(V(this,yt)),a(r.reason)}),s.send(JSON.stringify({jsonrpc:"2.0",id:V(this,yt),method:e,params:n}))}).then(({error:i,result:a})=>{if(i)throw new fc(i.message,i.code);return a})}async subscribe(e){const n=new vh(e);return V(this,Hn).add(n),await n.subscribe(this),()=>n.unsubscribe(this)}}yt=new WeakMap;Cn=new WeakMap;ot=new WeakMap;Dt=new WeakMap;Hn=new WeakMap;zt=new WeakMap;Ur=new WeakSet;mc=function(){return V(this,Dt)?V(this,Dt):(cn(this,Dt,new Promise(t=>{V(this,ot)?.close(),cn(this,ot,new this.options.WebSocketConstructor(this.endpoint)),V(this,ot).addEventListener("open",()=>{cn(this,Cn,0),t(V(this,ot))}),V(this,ot).addEventListener("close",()=>{mh(this,Cn)._++,V(this,Cn)<=this.options.maxReconnects&&setTimeout(()=>{gc(this,Ur,bc).call(this)},this.options.reconnectTimeout)}),V(this,ot).addEventListener("message",({data:e})=>{let n;try{n=JSON.parse(e)}catch(r){console.error(new Error(`Failed to parse RPC message: ${e}`,{cause:r}));return}if("id"in n&&n.id!=null&&V(this,zt).has(n.id)){const{resolve:r,timeout:s}=V(this,zt).get(n.id);clearTimeout(s),r(n)}else if("params"in n){const{params:r}=n;V(this,Hn).forEach(s=>{s.subscriptionId===r.subscription&&r.subscription===s.subscriptionId&&s.onMessage(r.result)})}})})),V(this,Dt))};bc=async function(){return V(this,ot)?.close(),cn(this,Dt,null),Promise.allSettled([...V(this,Hn)].map(t=>t.subscribe(this)))};class vh{constructor(e){this.subscriptionId=null,this.subscribed=!1,this.input=e}onMessage(e){this.subscribed&&this.input.onMessage(e)}async unsubscribe(e){const{subscriptionId:n}=this;return this.subscribed=!1,n==null?!1:(this.subscriptionId=null,e.makeRequest(this.input.unsubscribe,[n]))}async subscribe(e){this.subscriptionId=null,this.subscribed=!0;const n=await e.makeRequest(this.input.method,this.input.params,this.input.signal);this.subscribed&&(this.subscriptionId=n)}}var yc=t=>{throw TypeError(t)},vi=(t,e,n)=>e.has(t)||yc("Cannot "+n),Ee=(t,e,n)=>(vi(t,e,"read from private field"),n?n.call(t):e.get(t)),Zn=(t,e,n)=>e.has(t)?yc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),zs=(t,e,n,r)=>(vi(t,e,"write to private field"),e.set(t,n),n),_h=(t,e,n)=>(vi(t,e,"access private method"),n),$n,De,jn,Vs,wc;class Sh{constructor(e){Zn(this,Vs),Zn(this,$n,0),Zn(this,De),Zn(this,jn),zs(this,De,e)}fetch(e,n){const r=Ee(this,De).fetch??fetch;if(!r)throw new Error("The current environment does not support fetch, you can provide a fetch implementation in the options for SuiHTTPTransport.");return r(e,n)}async request(e){zs(this,$n,Ee(this,$n)+1);const n=await this.fetch(Ee(this,De).rpc?.url??Ee(this,De).url,{method:"POST",signal:e.signal,headers:{"Content-Type":"application/json","Client-Sdk-Type":"typescript","Client-Sdk-Version":Zo,"Client-Target-Api-Version":th,"Client-Request-Method":e.method,...Ee(this,De).rpc?.headers},body:JSON.stringify({jsonrpc:"2.0",id:Ee(this,$n),method:e.method,params:e.params})});if(!n.ok)throw new gh(`Unexpected status code: ${n.status}`,n.status,n.statusText);const r=await n.json();if("error"in r&&r.error!=null)throw new fc(r.error.message,r.error.code);return r.result}async subscribe(e){const n=await _h(this,Vs,wc).call(this).subscribe(e);return e.signal&&(e.signal.throwIfAborted(),e.signal.addEventListener("abort",()=>{n()})),async()=>!!await n()}}$n=new WeakMap;De=new WeakMap;jn=new WeakMap;Vs=new WeakSet;wc=function(){if(!Ee(this,jn)){const t=Ee(this,De).WebSocketConstructor??WebSocket;if(!t)throw new Error("The current environment does not support WebSocket, you can provide a WebSocketConstructor in the options for SuiHTTPTransport.");zs(this,jn,new wh(Ee(this,De).websocket?.url??Ee(this,De).url,{WebSocketConstructor:t,...Ee(this,De).websocket}))}return Ee(this,jn)};function Ig(t){switch(t){case"mainnet":return"https://fullnode.mainnet.sui.io:443";case"testnet":return"https://fullnode.testnet.sui.io:443";case"devnet":return"https://fullnode.devnet.sui.io:443";case"localnet":return"http://127.0.0.1:9000";default:throw new Error(`Unknown network: ${t}`)}}class vc{constructor({network:e,base:n,cache:r=n?.cache??new Zr}){this.network=e,this.base=n??this,this.cache=r}$extend(...e){return Object.create(this,Object.fromEntries(e.map(n=>{if("experimental_asClientExtension"in n){const{name:r,register:s}=n.experimental_asClientExtension();return[r,{value:s(this)}]}return[n.name,{value:n.register(this)}]})))}}const kh={mainnet:"https://mainnet.mvr.mystenlabs.com",testnet:"https://testnet.mvr.mystenlabs.com"};class Eh extends vc{constructor(e){super(e),this.core=this,this.mvr=new sh({cache:this.cache.scope("core.mvr"),url:e.mvr?.url??kh[this.network],pageSize:e.mvr?.pageSize,overrides:e.mvr?.overrides})}async getObject(e){const{objectId:n}=e,{objects:[r]}=await this.getObjects({objectIds:[n],signal:e.signal});if(r instanceof Error)throw r;return{object:r}}async getDynamicField(e){const n=zo(e.parentId,Ie.parseFromStr(e.name.type),e.name.bcs),{objects:[r]}=await this.getObjects({objectIds:[n],signal:e.signal});if(r instanceof Error)throw r;const s=ut(r.type),i=await r.content;return{dynamicField:{id:r.id,digest:r.digest,version:r.version,type:r.type,name:{type:typeof s.typeParams[0]=="string"?s.typeParams[0]:Gt(s.typeParams[0]),bcs:e.name.bcs},value:{type:typeof s.typeParams[1]=="string"?s.typeParams[1]:Gt(s.typeParams[1]),bcs:i.slice(Qr+e.name.bcs.length)}}}}async waitForTransaction({signal:e,timeout:n=60*1e3,...r}){const s=e?AbortSignal.any([AbortSignal.timeout(n),e]):AbortSignal.timeout(n),i=new Promise((a,o)=>{s.addEventListener("abort",()=>o(s.reason))});for(i.catch(()=>{});;){s.throwIfAborted();try{return await this.getTransaction({...r,signal:s})}catch{await Promise.race([new Promise(o=>setTimeout(o,2e3)),i])}}}}class Ih extends Error{}class It extends Ih{constructor(e,n){super(n),this.code=e}static fromResponse(e,n){switch(e.code){case"notExists":return new It(e.code,`Object ${e.object_id} does not exist`);case"dynamicFieldNotFound":return new It(e.code,`Dynamic field not found for object ${e.parent_object_id}`);case"deleted":return new It(e.code,`Object ${e.object_id} has been deleted`);case"displayError":return new It(e.code,`Display error: ${e.error}`);case"unknown":default:return new It(e.code,`Unknown error while loading object${n?` ${n}`:""}`)}}}function Th(t){return{...de.fromBytes(t).snapshot(),bcs:t}}function $h(t){const e=f.TransactionEffects.parse(t);switch(e.$kind){case"V1":return Oh({effects:e.V1});case"V2":return xh({bytes:t,effects:e.V2});default:throw new Error(`Unknown transaction effects version: ${e.$kind}`)}}function Oh(t){throw new Error("V1 effects are not supported yet")}function xh({bytes:t,effects:e}){const n=e.changedObjects.map(([r,s])=>({id:r,inputState:s.inputState.$kind==="Exist"?"Exists":"DoesNotExist",inputVersion:s.inputState.Exist?.[0][0]??null,inputDigest:s.inputState.Exist?.[0][1]??null,inputOwner:s.inputState.Exist?.[1]??null,outputState:s.outputState.$kind==="NotExist"?"DoesNotExist":s.outputState.$kind,outputVersion:s.outputState.$kind==="PackageWrite"?s.outputState.PackageWrite?.[0]:s.outputState.ObjectWrite?e.lamportVersion:null,outputDigest:s.outputState.$kind==="PackageWrite"?s.outputState.PackageWrite?.[1]:s.outputState.ObjectWrite?.[0]??null,outputOwner:s.outputState.ObjectWrite?s.outputState.ObjectWrite[1]:null,idOperation:s.idOperation.$kind}));return{bcs:t,digest:e.transactionDigest,version:2,status:e.status.$kind==="Success"?{success:!0,error:null}:{success:!1,error:e.status.Failed.error.$kind},gasUsed:e.gasUsed,transactionDigest:e.transactionDigest,gasObject:e.gasObjectIndex===null?null:n[e.gasObjectIndex]??null,eventsDigest:e.eventsDigest,dependencies:e.dependencies,lamportVersion:e.lamportVersion,changedObjects:n,unchangedSharedObjects:e.unchangedSharedObjects.map(([r,s])=>({kind:s.$kind==="MutateDeleted"?"MutateConsensusStreamEnded":s.$kind==="ReadDeleted"?"ReadConsensusStreamEnded":s.$kind,objectId:r,version:s.$kind==="ReadOnlyRoot"?s.ReadOnlyRoot[0]:s[s.$kind],digest:s.$kind==="ReadOnlyRoot"?s.ReadOnlyRoot[1]:null})),auxiliaryDataDigest:e.auxDataDigest}}var _c=t=>{throw TypeError(t)},Sc=(t,e,n)=>e.has(t)||_c("Cannot "+n),ge=(t,e,n)=>(Sc(t,e,"read from private field"),n?n.call(t):e.get(t)),Mh=(t,e,n)=>e.has(t)?_c("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),Ah=(t,e,n,r)=>(Sc(t,e,"write to private field"),e.set(t,n),n),ne;class Bh extends Eh{constructor({jsonRpcClient:e,mvr:n}){super({network:e.network,base:e,mvr:n}),Mh(this,ne),Ah(this,ne,e)}async getObjects(e){const n=fn(e.objectIds,50),r=[];for(const s of n){const i=await ge(this,ne).multiGetObjects({ids:s,options:{showOwner:!0,showType:!0,showBcs:!0},signal:e.signal});for(const[a,o]of i.entries())o.error?r.push(It.fromResponse(o.error,s[a])):r.push(ca(o.data))}return{objects:r}}async getOwnedObjects(e){const n=await ge(this,ne).getOwnedObjects({owner:e.address,limit:e.limit,cursor:e.cursor,options:{showOwner:!0,showType:!0,showBcs:!0},filter:e.type?{StructType:e.type}:null,signal:e.signal});return{objects:n.data.map(r=>{if(r.error)throw It.fromResponse(r.error);return ca(r.data)}),hasNextPage:n.hasNextPage,cursor:n.nextCursor??null}}async getCoins(e){const n=await ge(this,ne).getCoins({owner:e.address,coinType:e.coinType,limit:e.limit,cursor:e.cursor,signal:e.signal});return{objects:n.data.map(r=>({id:r.coinObjectId,version:r.version,digest:r.digest,balance:r.balance,type:`0x2::coin::Coin<${r.coinType}>`,content:Promise.resolve(Ph.serialize({id:r.coinObjectId,balance:{value:r.balance}}).toBytes()),owner:{$kind:"ObjectOwner",ObjectOwner:e.address}})),hasNextPage:n.hasNextPage,cursor:n.nextCursor??null}}async getBalance(e){const n=await ge(this,ne).getBalance({owner:e.address,coinType:e.coinType,signal:e.signal});return{balance:{coinType:n.coinType,balance:n.totalBalance}}}async getAllBalances(e){return{balances:(await ge(this,ne).getAllBalances({owner:e.address,signal:e.signal})).map(r=>({coinType:r.coinType,balance:r.totalBalance})),hasNextPage:!1,cursor:null}}async getTransaction(e){const n=await ge(this,ne).getTransactionBlock({digest:e.digest,options:{showRawInput:!0,showObjectChanges:!0,showRawEffects:!0,showEvents:!0,showEffects:!0},signal:e.signal});return{transaction:ua(n)}}async executeTransaction(e){const n=await ge(this,ne).executeTransactionBlock({transactionBlock:e.transaction,signature:e.signatures,options:{showRawEffects:!0,showEvents:!0,showObjectChanges:!0,showRawInput:!0,showEffects:!0},signal:e.signal});return{transaction:ua(n)}}async dryRunTransaction(e){const n=Ae.from(e.transaction),r=await ge(this,ne).dryRunTransactionBlock({transactionBlock:e.transaction,signal:e.signal}),{effects:s,objectTypes:i}=Ch({effects:r.effects,objectChanges:r.objectChanges});return{transaction:{digest:await n.getDigest(),epoch:null,effects:s,objectTypes:Promise.resolve(i),signatures:[],transaction:Th(e.transaction)}}}async getReferenceGasPrice(e){const n=await ge(this,ne).getReferenceGasPrice({signal:e?.signal});return{referenceGasPrice:String(n)}}async getDynamicFields(e){const n=await ge(this,ne).getDynamicFields({parentId:e.parentId,limit:e.limit,cursor:e.cursor});return{dynamicFields:n.data.map(r=>({id:r.objectId,type:r.objectType,name:{type:r.name.type,bcs:Q(r.bcsName)}})),hasNextPage:n.hasNextPage,cursor:n.nextCursor}}async verifyZkLoginSignature(e){const n=await ge(this,ne).verifyZkLoginSignature({bytes:e.bytes,signature:e.signature,intentScope:e.intentScope,author:e.author});return{success:n.success,errors:n.errors}}resolveNameServiceNames(e){return ge(this,ne).resolveNameServiceNames(e)}resolveTransactionPlugin(){return qo(ge(this,ne))}}ne=new WeakMap;function ca(t){return{id:t.objectId,version:t.version,digest:t.digest,type:t.type,content:Promise.resolve(t.bcs?.dataType==="moveObject"?Q(t.bcs.bcsBytes):new Uint8Array),owner:en(t.owner)}}function en(t){if(t==="Immutable")return{$kind:"Immutable",Immutable:!0};if("ConsensusAddressOwner"in t)return{$kind:"ConsensusAddressOwner",ConsensusAddressOwner:{owner:t.ConsensusAddressOwner.owner,startVersion:t.ConsensusAddressOwner.start_version}};if("AddressOwner"in t)return{$kind:"AddressOwner",AddressOwner:t.AddressOwner};if("ObjectOwner"in t)return{$kind:"ObjectOwner",ObjectOwner:t.ObjectOwner};if("Shared"in t)return{$kind:"Shared",Shared:{initialSharedVersion:t.Shared.initial_shared_version}};throw new Error(`Unknown owner type: ${JSON.stringify(t)}`)}function ua(t){const e=f.SenderSignedData.parse(Q(t.rawTransaction))[0],n={};t.objectChanges?.forEach(i=>{i.type!=="published"&&(n[i.objectId]=i.objectType)});const r=f.TransactionData.serialize(e.intentMessage.value).toBytes(),s=de.restore({version:2,sender:e.intentMessage.value.V1.sender,expiration:e.intentMessage.value.V1.expiration,gasData:e.intentMessage.value.V1.gasData,inputs:e.intentMessage.value.V1.kind.ProgrammableTransaction.inputs,commands:e.intentMessage.value.V1.kind.ProgrammableTransaction.commands});return{digest:t.digest,epoch:t.effects?.executedEpoch??null,effects:$h(new Uint8Array(t.rawEffects)),objectTypes:Promise.resolve(n),transaction:{...s,bcs:r},signatures:e.txSignatures}}function Ch({bytes:t,effects:e,objectChanges:n}){const r=[],s=[],i={};return n?.forEach(a=>{switch(a.type){case"published":r.push({id:a.packageId,inputState:"DoesNotExist",inputVersion:null,inputDigest:null,inputOwner:null,outputState:"PackageWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:null,idOperation:"Created"});break;case"transferred":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.version,inputDigest:a.digest,inputOwner:{$kind:"AddressOwner",AddressOwner:a.sender},outputState:"ObjectWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:en(a.recipient),idOperation:"None"}),i[a.objectId]=a.objectType;break;case"mutated":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.previousVersion,inputDigest:null,inputOwner:en(a.owner),outputState:"ObjectWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:en(a.owner),idOperation:"None"}),i[a.objectId]=a.objectType;break;case"deleted":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.version,inputDigest:e.deleted?.find(o=>o.objectId===a.objectId)?.digest??null,inputOwner:null,outputState:"DoesNotExist",outputVersion:null,outputDigest:null,outputOwner:null,idOperation:"Deleted"}),i[a.objectId]=a.objectType;break;case"wrapped":r.push({id:a.objectId,inputState:"Exists",inputVersion:a.version,inputDigest:null,inputOwner:{$kind:"AddressOwner",AddressOwner:a.sender},outputState:"ObjectWrite",outputVersion:a.version,outputDigest:e.wrapped?.find(o=>o.objectId===a.objectId)?.digest??null,outputOwner:{$kind:"ObjectOwner",ObjectOwner:a.sender},idOperation:"None"}),i[a.objectId]=a.objectType;break;case"created":r.push({id:a.objectId,inputState:"DoesNotExist",inputVersion:null,inputDigest:null,inputOwner:null,outputState:"ObjectWrite",outputVersion:a.version,outputDigest:a.digest,outputOwner:en(a.owner),idOperation:"Created"}),i[a.objectId]=a.objectType;break}}),{objectTypes:i,effects:{bcs:t??null,digest:e.transactionDigest,version:2,status:e.status.status==="success"?{success:!0,error:null}:{success:!1,error:e.status.error},gasUsed:e.gasUsed,transactionDigest:e.transactionDigest,gasObject:{id:e.gasObject?.reference.objectId,inputState:"Exists",inputVersion:null,inputDigest:null,inputOwner:null,outputState:"ObjectWrite",outputVersion:e.gasObject.reference.version,outputDigest:e.gasObject.reference.digest,outputOwner:en(e.gasObject.owner),idOperation:"None"},eventsDigest:e.eventsDigest??null,dependencies:e.dependencies??[],lamportVersion:e.gasObject.reference.version,changedObjects:r,unchangedSharedObjects:s,auxiliaryDataDigest:null}}}const jh=f.struct("Balance",{value:f.u64()}),Ph=f.struct("Coin",{id:f.Address,balance:jh}),kc=Symbol.for("@mysten/SuiClient");function Tg(t){return typeof t=="object"&&t!==null&&t[kc]===!0}class Uh extends vc{constructor(e){super({network:e.network??"unknown"}),this.jsonRpc=this,this.transport=e.transport??new Sh({url:e.url}),this.core=new Bh({jsonRpcClient:this,mvr:e.mvr})}get[kc](){return!0}async getRpcApiVersion({signal:e}={}){return(await this.transport.request({method:"rpc.discover",params:[],signal:e})).info.version}async getCoins({coinType:e,owner:n,cursor:r,limit:s,signal:i}){if(!n||!Ne(C(n)))throw new Error("Invalid Sui address");return e&&he(e)&&(e=(await this.core.mvr.resolveType({type:e})).type),await this.transport.request({method:"suix_getCoins",params:[n,e,r,s],signal:i})}async getAllCoins(e){if(!e.owner||!Ne(C(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllCoins",params:[e.owner,e.cursor,e.limit],signal:e.signal})}async getBalance({owner:e,coinType:n,signal:r}){if(!e||!Ne(C(e)))throw new Error("Invalid Sui address");return n&&he(n)&&(n=(await this.core.mvr.resolveType({type:n})).type),await this.transport.request({method:"suix_getBalance",params:[e,n],signal:r})}async getAllBalances(e){if(!e.owner||!Ne(C(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getAllBalances",params:[e.owner],signal:e.signal})}async getCoinMetadata({coinType:e,signal:n}){return e&&he(e)&&(e=(await this.core.mvr.resolveType({type:e})).type),await this.transport.request({method:"suix_getCoinMetadata",params:[e],signal:n})}async getTotalSupply({coinType:e,signal:n}){return e&&he(e)&&(e=(await this.core.mvr.resolveType({type:e})).type),await this.transport.request({method:"suix_getTotalSupply",params:[e],signal:n})}async call(e,n,{signal:r}={}){return await this.transport.request({method:e,params:n,signal:r})}async getMoveFunctionArgTypes({package:e,module:n,function:r,signal:s}){return e&&be(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getMoveFunctionArgTypes",params:[e,n,r],signal:s})}async getNormalizedMoveModulesByPackage({package:e,signal:n}){return e&&be(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveModulesByPackage",params:[e],signal:n})}async getNormalizedMoveModule({package:e,module:n,signal:r}){return e&&be(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveModule",params:[e,n],signal:r})}async getNormalizedMoveFunction({package:e,module:n,function:r,signal:s}){return e&&be(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveFunction",params:[e,n,r],signal:s})}async getNormalizedMoveStruct({package:e,module:n,struct:r,signal:s}){return e&&be(e)&&(e=(await this.core.mvr.resolvePackage({package:e})).package),await this.transport.request({method:"sui_getNormalizedMoveStruct",params:[e,n,r],signal:s})}async getOwnedObjects(e){if(!e.owner||!Ne(C(e.owner)))throw new Error("Invalid Sui address");const n=e.filter?{...e.filter}:void 0;return n&&"MoveModule"in n&&be(n.MoveModule.package)?n.MoveModule={module:n.MoveModule.module,package:(await this.core.mvr.resolvePackage({package:n.MoveModule.package})).package}:n&&"StructType"in n&&he(n.StructType)&&(n.StructType=(await this.core.mvr.resolveType({type:n.StructType})).type),await this.transport.request({method:"suix_getOwnedObjects",params:[e.owner,{filter:n,options:e.options},e.cursor,e.limit],signal:e.signal})}async getObject(e){if(!e.id||!Jn(ct(e.id)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"sui_getObject",params:[e.id,e.options],signal:e.signal})}async tryGetPastObject(e){return await this.transport.request({method:"sui_tryGetPastObject",params:[e.id,e.version,e.options],signal:e.signal})}async multiGetObjects(e){if(e.ids.forEach(r=>{if(!r||!Jn(ct(r)))throw new Error(`Invalid Sui Object id ${r}`)}),e.ids.length!==new Set(e.ids).size)throw new Error(`Duplicate object ids in batch call ${e.ids}`);return await this.transport.request({method:"sui_multiGetObjects",params:[e.ids,e.options],signal:e.signal})}async queryTransactionBlocks({filter:e,options:n,cursor:r,limit:s,order:i,signal:a}){return e&&"MoveFunction"in e&&be(e.MoveFunction.package)&&(e={...e,MoveFunction:{package:(await this.core.mvr.resolvePackage({package:e.MoveFunction.package})).package}}),await this.transport.request({method:"suix_queryTransactionBlocks",params:[{filter:e,options:n},r,s,(i||"descending")==="descending"],signal:a})}async getTransactionBlock(e){if(!Li(e.digest))throw new Error("Invalid Transaction digest");return await this.transport.request({method:"sui_getTransactionBlock",params:[e.digest,e.options],signal:e.signal})}async multiGetTransactionBlocks(e){if(e.digests.forEach(r=>{if(!Li(r))throw new Error(`Invalid Transaction digest ${r}`)}),e.digests.length!==new Set(e.digests).size)throw new Error(`Duplicate digests in batch call ${e.digests}`);return await this.transport.request({method:"sui_multiGetTransactionBlocks",params:[e.digests,e.options],signal:e.signal})}async executeTransactionBlock({transactionBlock:e,signature:n,options:r,requestType:s,signal:i}){const a=await this.transport.request({method:"sui_executeTransactionBlock",params:[typeof e=="string"?e:X(e),Array.isArray(n)?n:[n],r],signal:i});if(s==="WaitForLocalExecution")try{await this.waitForTransaction({digest:a.digest})}catch{}return a}async signAndExecuteTransaction({transaction:e,signer:n,...r}){let s;e instanceof Uint8Array?s=e:(e.setSenderIfNotSet(n.toSuiAddress()),s=await e.build({client:this}));const{signature:i,bytes:a}=await n.signTransaction(s);return this.executeTransactionBlock({transactionBlock:a,signature:i,...r})}async getTotalTransactionBlocks({signal:e}={}){const n=await this.transport.request({method:"sui_getTotalTransactionBlocks",params:[],signal:e});return BigInt(n)}async getReferenceGasPrice({signal:e}={}){const n=await this.transport.request({method:"suix_getReferenceGasPrice",params:[],signal:e});return BigInt(n)}async getStakes(e){if(!e.owner||!Ne(C(e.owner)))throw new Error("Invalid Sui address");return await this.transport.request({method:"suix_getStakes",params:[e.owner],signal:e.signal})}async getStakesByIds(e){return e.stakedSuiIds.forEach(n=>{if(!n||!Jn(ct(n)))throw new Error(`Invalid Sui Stake id ${n}`)}),await this.transport.request({method:"suix_getStakesByIds",params:[e.stakedSuiIds],signal:e.signal})}async getLatestSuiSystemState({signal:e}={}){return await this.transport.request({method:"suix_getLatestSuiSystemState",params:[],signal:e})}async queryEvents({query:e,cursor:n,limit:r,order:s,signal:i}){return e&&"MoveEventType"in e&&he(e.MoveEventType)&&(e={...e,MoveEventType:(await this.core.mvr.resolveType({type:e.MoveEventType})).type}),e&&"MoveEventModule"in e&&be(e.MoveEventModule.package)&&(e={...e,MoveEventModule:{module:e.MoveEventModule.module,package:(await this.core.mvr.resolvePackage({package:e.MoveEventModule.package})).package}}),"MoveModule"in e&&be(e.MoveModule.package)&&(e={...e,MoveModule:{module:e.MoveModule.module,package:(await this.core.mvr.resolvePackage({package:e.MoveModule.package})).package}}),await this.transport.request({method:"suix_queryEvents",params:[e,n,r,(s||"descending")==="descending"],signal:i})}async subscribeEvent(e){return this.transport.subscribe({method:"suix_subscribeEvent",unsubscribe:"suix_unsubscribeEvent",params:[e.filter],onMessage:e.onMessage,signal:e.signal})}async subscribeTransaction(e){return this.transport.subscribe({method:"suix_subscribeTransaction",unsubscribe:"suix_unsubscribeTransaction",params:[e.filter],onMessage:e.onMessage,signal:e.signal})}async devInspectTransactionBlock(e){let n;if(uc(e.transactionBlock))e.transactionBlock.setSenderIfNotSet(e.sender),n=X(await e.transactionBlock.build({client:this,onlyTransactionKind:!0}));else if(typeof e.transactionBlock=="string")n=e.transactionBlock;else if(e.transactionBlock instanceof Uint8Array)n=X(e.transactionBlock);else throw new Error("Unknown transaction block format.");return e.signal?.throwIfAborted(),await this.transport.request({method:"sui_devInspectTransactionBlock",params:[e.sender,n,e.gasPrice?.toString(),e.epoch],signal:e.signal})}async dryRunTransactionBlock(e){return await this.transport.request({method:"sui_dryRunTransactionBlock",params:[typeof e.transactionBlock=="string"?e.transactionBlock:X(e.transactionBlock)]})}async getDynamicFields(e){if(!e.parentId||!Jn(ct(e.parentId)))throw new Error("Invalid Sui Object id");return await this.transport.request({method:"suix_getDynamicFields",params:[e.parentId,e.cursor,e.limit],signal:e.signal})}async getDynamicFieldObject(e){return await this.transport.request({method:"suix_getDynamicFieldObject",params:[e.parentId,e.name],signal:e.signal})}async getLatestCheckpointSequenceNumber({signal:e}={}){const n=await this.transport.request({method:"sui_getLatestCheckpointSequenceNumber",params:[],signal:e});return String(n)}async getCheckpoint(e){return await this.transport.request({method:"sui_getCheckpoint",params:[e.id],signal:e.signal})}async getCheckpoints(e){return await this.transport.request({method:"sui_getCheckpoints",params:[e.cursor,e?.limit,e.descendingOrder],signal:e.signal})}async getCommitteeInfo(e){return await this.transport.request({method:"suix_getCommitteeInfo",params:[e?.epoch],signal:e?.signal})}async getNetworkMetrics({signal:e}={}){return await this.transport.request({method:"suix_getNetworkMetrics",params:[],signal:e})}async getAddressMetrics({signal:e}={}){return await this.transport.request({method:"suix_getLatestAddressMetrics",params:[],signal:e})}async getEpochMetrics(e){return await this.transport.request({method:"suix_getEpochMetrics",params:[e?.cursor,e?.limit,e?.descendingOrder],signal:e?.signal})}async getAllEpochAddressMetrics(e){return await this.transport.request({method:"suix_getAllEpochAddressMetrics",params:[e?.descendingOrder],signal:e?.signal})}async getEpochs(e){return await this.transport.request({method:"suix_getEpochs",params:[e?.cursor,e?.limit,e?.descendingOrder],signal:e?.signal})}async getMoveCallMetrics({signal:e}={}){return await this.transport.request({method:"suix_getMoveCallMetrics",params:[],signal:e})}async getCurrentEpoch({signal:e}={}){return await this.transport.request({method:"suix_getCurrentEpoch",params:[],signal:e})}async getValidatorsApy({signal:e}={}){return await this.transport.request({method:"suix_getValidatorsApy",params:[],signal:e})}async getChainIdentifier({signal:e}={}){const n=await this.getCheckpoint({id:"0",signal:e}),r=zn(n.digest);return hn(r.slice(0,4))}async resolveNameServiceAddress(e){return await this.transport.request({method:"suix_resolveNameServiceAddress",params:[e.name],signal:e.signal})}async resolveNameServiceNames({format:e="dot",...n}){const{nextCursor:r,hasNextPage:s,data:i}=await this.transport.request({method:"suix_resolveNameServiceNames",params:[n.address,n.cursor,n.limit],signal:n.signal});return{hasNextPage:s,nextCursor:r,data:i.map(a=>Ku(a,e))}}async getProtocolConfig(e){return await this.transport.request({method:"sui_getProtocolConfig",params:[e?.version],signal:e?.signal})}async verifyZkLoginSignature(e){return await this.transport.request({method:"sui_verifyZkLoginSignature",params:[e.bytes,e.signature,e.intentScope,e.author],signal:e.signal})}async waitForTransaction({signal:e,timeout:n=60*1e3,pollInterval:r=2*1e3,...s}){const i=AbortSignal.timeout(n),a=new Promise((o,c)=>{i.addEventListener("abort",()=>c(i.reason))});for(a.catch(()=>{});!i.aborted;){e?.throwIfAborted();try{return await this.getTransactionBlock(s)}catch{await Promise.race([new Promise(c=>setTimeout(c,r)),a])}}throw i.throwIfAborted(),new Error("Unexpected error while waiting for transaction block.")}experimental_asClientExtension(){return{name:"jsonRPC",register:()=>this}}}const Rh={systemObjectId:"0x6c2547cbbc38025cf3adac45f63cb0a8d12ecf777cdc75a4971612bf97fdf6af",stakingPoolId:"0xbe46180321c30aab2f8b3501e24048377287fa708018a5b7c2792b35fe339ee3",exchangeIds:["0xf4d164ea2def5fe07dc573992a029e010dba09b1a8dcbc44c5c2e79567f39073","0x19825121c52080bb1073662231cfea5c0e4d905fd13e95f21e9a018f2ef41862","0x83b454e524c71f30803f4d6c302a86fb6a39e96cdfb873c2d1e93bc1c26a3bc5","0x8d63209cf8589ce7aef8f262437163c67577ed09f3e636a9d8e0813843fb8bf1"]},Nh={systemObjectId:"0x2134d52768ea07e8c43570ef975eb3e4c27a39fa6396bef985b5abc58d03ddd2",stakingPoolId:"0x10b9d30c28448939ce6c4d6c6e0ffce4a7f8a4ada8248bdad09ef8b70e4a3904"},la={nonexistent:0,deletable:1,permanent:2,invalid:3},Dh=C("0x1"),fr=C("0x2"),zh=C("0x3");function Ws(t){const e=typeof t=="string"?Ie.parseFromStr(t):t;if("u8"in e)return f.U8;if("u16"in e)return f.U16;if("u32"in e)return f.U32;if("u64"in e)return f.U64;if("u128"in e)return f.U128;if("u256"in e)return f.U256;if("address"in e)return f.Address;if("bool"in e)return f.Bool;if("vector"in e){const n=Ws(e.vector);return n?f.vector(n):null}else if("struct"in e){const n=e.struct,r=C(e.struct.address);if(r===Dh){if((n.module==="ascii"||n.module==="string")&&n.name==="String")return f.String;if(n.module==="option"&&n.name==="Option"){const s=Ws(n.typeParams[0]);return s?f.vector(s):null}}if(r===fr&&n.module==="Object"&&n.name==="ID")return f.Address}return null}function xt(t,e,n){if(n&&e.length!==n.length)throw new Error(`Invalid number of parameterNames, expected ${e.length}, got ${n.length}`);const r=[];let s=0;for(const[i,a]of e.entries()){if(a===`${fr}::deny_list::DenyList`){r.push(u=>u.object.denyList());continue}if(a===`${fr}::random::Random`){r.push(u=>u.object.random());continue}if(a===`${fr}::clock::Clock`){r.push(u=>u.object.clock());continue}if(a===`${zh}::sui_system::SuiSystemState`){r.push(u=>u.object.system());continue}let o;if(Array.isArray(t)){if(s>=t.length)throw new Error(`Invalid number of arguments, expected at least ${s+1}, got ${t.length}`);o=t[s]}else{if(!n)throw new Error("Expected arguments to be passed as an array");const u=n[s];if(o=t[u],o==null)throw new Error(`Parameter ${u} is required`)}if(s+=1,typeof o=="function"||Zd(o)){r.push(o);continue}const c=e[i],l=Ws(c);if(l){const u=l.serialize(o);r.push(h=>h.pure(u));continue}else if(typeof o=="string"){r.push(u=>u.object(o));continue}throw new Error(`Invalid argument ${Vh(o)} for type ${c}`)}return r}class U extends Qa{}class Qn extends Ja{}class _i extends Xa{}function Vh(t){return typeof t=="object"?JSON.stringify(t,e=>e):typeof t=="bigint"?t.toString():t}const Wh="0x2::object",Xe=new U({name:`${Wh}::UID`,fields:{id:f.Address}}),Fh="@local-pkg/walrus::storage_resource",Ec=new U({name:`${Fh}::Storage`,fields:{id:Xe,start_epoch:f.u32(),end_epoch:f.u32(),storage_size:f.u64()}}),Ic="@local-pkg/walrus::blob",On=new U({name:`${Ic}::Blob`,fields:{id:Xe,registered_epoch:f.u32(),blob_id:f.u256(),size:f.u64(),encoding_type:f.u8(),certified_epoch:f.option(f.u32()),storage:Ec,deletable:f.bool()}});new U({name:`${Ic}::BlobIdDerivation`,fields:{encoding_type:f.u8(),size:f.u64(),root_hash:f.u256()}});function Lh(t){const e=t.package??"@local-pkg/walrus",n=[`${e}::blob::Blob`,`${e}::metadata::Metadata`],r=["self","metadata"];return s=>s.moveCall({package:e,module:"blob",function:"add_metadata",arguments:xt(t.arguments,n,r)})}function Gh(t){const e=t.package??"@local-pkg/walrus",n=[`${e}::blob::Blob`,"0x0000000000000000000000000000000000000000000000000000000000000001::string::String","0x0000000000000000000000000000000000000000000000000000000000000001::string::String"],r=["self","key","value"];return s=>s.moveCall({package:e,module:"blob",function:"insert_or_update_metadata_pair",arguments:xt(t.arguments,n,r)})}function Hh(t){const e=t.package??"@local-pkg/walrus",n=[`${e}::blob::Blob`,"0x0000000000000000000000000000000000000000000000000000000000000001::string::String"],r=["self","key"];return s=>s.moveCall({package:e,module:"blob",function:"remove_metadata_pair",arguments:xt(t.arguments,n,r)})}const Tc="0x2::vec_map";function qh(...t){return new U({name:`${Tc}::Entry<${t[0].name}, ${t[1].name}>`,fields:{key:t[0],value:t[1]}})}function ts(...t){return new U({name:`${Tc}::VecMap<${t[0].name}, ${t[1].name}>`,fields:{contents:f.vector(qh(t[0],t[1]))}})}const Kh="@local-pkg/walrus::metadata",Qh=new U({name:`${Kh}::Metadata`,fields:{metadata:ts(f.string(),f.string())}});function Jh(t={}){const e=t.package??"@local-pkg/walrus";return n=>n.moveCall({package:e,module:"metadata",function:"new"})}const Xh="0x2::object_table",Yh=new U({name:`${Xh}::ObjectTable`,fields:{id:Xe,size:f.u64()}}),$c="@local-pkg/walrus::extended_field",Rr=new U({name:`${$c}::ExtendedField`,fields:{id:Xe}});new _i({name:`${$c}::Key`,fields:[f.bool()]});const Zh="@local-pkg/walrus::committee",fs=new _i({name:`${Zh}::Committee`,fields:[ts(f.Address,f.vector(f.u16()))]}),ef="@local-pkg/walrus::epoch_parameters",tf=new U({name:`${ef}::EpochParams`,fields:{total_capacity_size:f.u64(),storage_price_per_unit_size:f.u64(),write_price_per_unit_size:f.u64()}}),Oc="@local-pkg/walrus::staking_inner",nf=new Qn({name:`${Oc}::EpochState`,fields:{EpochChangeSync:f.u16(),EpochChangeDone:f.u64(),NextParamsSelected:f.u64()}}),rf=new U({name:`${Oc}::StakingInnerV1`,fields:{n_shards:f.u16(),epoch_duration:f.u64(),first_epoch_start:f.u64(),pools:Yh,epoch:f.u32(),active_set:Rr,next_committee:f.option(fs),committee:fs,previous_committee:fs,next_epoch_params:f.option(tf),epoch_state:nf,next_epoch_public_keys:Rr}}),sf="0x2::group_ops",Nr=new U({name:`${sf}::Element`,fields:{bytes:f.vector(f.u8())}}),Si="@local-pkg/walrus::event_blob",af=new U({name:`${Si}::EventBlobAttestation`,fields:{checkpoint_sequence_num:f.u64(),epoch:f.u32()}}),da=new U({name:`${Si}::EventBlob`,fields:{blob_id:f.u256(),ending_checkpoint_sequence_number:f.u64()}}),of=new U({name:`${Si}::EventBlobCertificationState`,fields:{latest_certified_blob:f.option(da),aggregate_weight_per_blob:ts(da,f.u16())}}),xc="@local-pkg/walrus::storage_node",cf=new U({name:`${xc}::StorageNodeInfo`,fields:{name:f.string(),node_id:f.Address,network_address:f.string(),public_key:Nr,next_epoch_public_key:f.option(Nr),network_public_key:f.vector(f.u8()),metadata:Rr}});new U({name:`${xc}::StorageNodeCap`,fields:{id:Xe,node_id:f.Address,last_epoch_sync_done:f.u32(),last_event_blob_attestation:f.option(af),deny_list_root:f.u256(),deny_list_sequence:f.u64(),deny_list_size:f.u64()}});const uf="@local-pkg/walrus::pending_values",er=new _i({name:`${uf}::PendingValues`,fields:[ts(f.u32(),f.u64())]}),lf="0x2::table",df=new U({name:`${lf}::Table`,fields:{id:Xe,size:f.u64()}}),hf="0x2::balance",Fs=new U({name:`${hf}::Balance`,fields:{value:f.u64()}}),Mc="@local-pkg/walrus::auth";new Qn({name:`${Mc}::Authenticated`,fields:{Sender:f.Address,Object:f.Address}});const ha=new Qn({name:`${Mc}::Authorized`,fields:{Address:f.Address,ObjectID:f.Address}}),ff="0x2::bag",pf=new U({name:`${ff}::Bag`,fields:{id:Xe,size:f.u64()}}),ki="@local-pkg/walrus::staking_pool",gf=new U({name:`${ki}::VotingParams`,fields:{storage_price:f.u64(),write_price:f.u64(),node_capacity:f.u64()}}),mf=new Qn({name:`${ki}::PoolState`,fields:{Active:null,Withdrawing:f.u32(),Withdrawn:null}}),bf=new U({name:`${ki}::StakingPool`,fields:{id:Xe,state:mf,voting_params:gf,node_info:cf,activation_epoch:f.u32(),latest_epoch:f.u32(),wal_balance:f.u64(),num_shares:f.u64(),pending_shares_withdraw:er,pre_active_withdrawals:er,pending_commission_rate:er,commission_rate:f.u16(),exchange_rates:df,pending_stake:er,rewards_pool:Fs,commission:Fs,commission_receiver:ha,governance_authorized:ha,extra_fields:pf}}),yf="@local-pkg/walrus::staking",wf=new U({name:`${yf}::Staking`,fields:{id:Xe,version:f.u64(),package_id:f.Address,new_package_id:f.option(f.Address)}}),Ei="@local-pkg/walrus::bls_aggregate",vf=new U({name:`${Ei}::BlsCommitteeMember`,fields:{public_key:Nr,weight:f.u16(),node_id:f.Address}}),_f=new U({name:`${Ei}::BlsCommittee`,fields:{members:f.vector(vf),n_shards:f.u16(),epoch:f.u32(),total_aggregated_key:Nr}});new Qn({name:`${Ei}::RequiredWeight`,fields:{Quorum:null,OneCorrectNode:null}});const Ac="@local-pkg/walrus::storage_accounting",Sf=new U({name:`${Ac}::FutureAccounting`,fields:{epoch:f.u32(),used_capacity:f.u64(),rewards_to_distribute:Fs}}),kf=new U({name:`${Ac}::FutureAccountingRingBuffer`,fields:{current_index:f.u32(),length:f.u32(),ring_buffer:f.vector(Sf)}}),Ef="@local-pkg/walrus::system_state_inner",If=new U({name:`${Ef}::SystemStateInnerV1`,fields:{committee:_f,total_capacity_size:f.u64(),used_capacity_size:f.u64(),storage_price_per_unit_size:f.u64(),write_price_per_unit_size:f.u64(),future_accounting:kf,event_blob_certification_state:of,deny_list_sizes:Rr}}),Tf="@local-pkg/walrus::system",$f=new U({name:`${Tf}::System`,fields:{id:Xe,version:f.u64(),package_id:f.Address,new_package_id:f.option(f.Address)}});function Of(t){const e=t.package??"@local-pkg/walrus",n=[`${e}::system::System`,"u64","u32",`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${e}::wal::WAL>`],r=["self","storageAmount","epochsAhead","payment"];return s=>s.moveCall({package:e,module:"system",function:"reserve_space",arguments:xt(t.arguments,n,r)})}function xf(t){const e=t.package??"@local-pkg/walrus",n=[`${e}::system::System`,`${e}::storage_resource::Storage`,"u256","u256","u64","u8","bool",`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${e}::wal::WAL>`],r=["self","storage","blobId","rootHash","size","encodingType","deletable","writePayment"];return s=>s.moveCall({package:e,module:"system",function:"register_blob",arguments:xt(t.arguments,n,r)})}function Mf(t){const e=t.package??"@local-pkg/walrus",n=[`${e}::system::System`,`${e}::blob::Blob`,"vector<u8>","vector<u8>","vector<u8>"],r=["self","blob","signature","signersBitmap","message"];return s=>s.moveCall({package:e,module:"system",function:"certify_blob",arguments:xt(t.arguments,n,r)})}function Af(t){const e=t.package??"@local-pkg/walrus",n=[`${e}::system::System`,`${e}::blob::Blob`],r=["self","blob"];return s=>s.moveCall({package:e,module:"system",function:"delete_blob",arguments:xt(t.arguments,n,r)})}function Bf(t){const e=t.package??"@local-pkg/walrus",n=[`${e}::system::System`,`${e}::blob::Blob`,"u32",`0x0000000000000000000000000000000000000000000000000000000000000002::coin::Coin<${e}::wal::WAL>`],r=["self","blob","extendedEpochs","payment"];return s=>s.moveCall({package:e,module:"system",function:"extend_blob",arguments:xt(t.arguments,n,r)})}class re extends Error{}class bn extends re{}class Cf extends re{}class jf extends re{}class Pf extends bn{}class Uf extends bn{}class fa extends bn{}class Rf extends bn{}class Pn extends bn{}class Nf extends re{}class pa extends Error{}const ga=f.enum("MerkleNode",{Empty:null,Digest:f.bytes(32)}),Df=f.struct("SliverPairMetadata",{primary_hash:ga,secondary_hash:ga}),zf=f.enum("EncodingType",{RedStuff:null,RS2:null}).transform({input:t=>typeof t=="string"?{[t]:null}:t,output:t=>t}),Vf=f.struct("BlobMetadataV1",{encoding_type:zf,unencoded_length:f.u64(),hashes:f.vector(Df)}),Bc=f.enum("BlobMetadata",{V1:Vf}),yn=f.u256().transform({input:t=>typeof t=="string"?jc(t):t,output:t=>Cc(t)});function Cc(t){return f.u256().serialize(t).toBase64().replace(/=*$/,"").replaceAll("+","-").replaceAll("/","_")}function ma(t){return Cc(f.u256().parse(t))}function jc(t){return BigInt(f.u256().fromBase64(t.replaceAll("-","+").replaceAll("_","/")))}const Wf=f.struct("BlobMetadataWithId",{blobId:yn,metadata:Bc}),Ff=f.struct("Symbols",{data:f.vector(f.u8()),symbol_size:f.u16()}),Ot=f.struct("SliverData",{symbols:Ff,index:f.u16()});f.enum("Sliver",{Primary:Ot,Secondary:Ot});f.struct("SliverPair",{primary:Ot,secondary:Ot});var Pc=(t=>(t[t.PROOF_OF_POSSESSION_MSG=0]="PROOF_OF_POSSESSION_MSG",t[t.BLOB_CERT_MSG=1]="BLOB_CERT_MSG",t[t.INVALID_BLOB_ID_MSG=2]="INVALID_BLOB_ID_MSG",t[t.SYNC_SHARD_MSG=3]="SYNC_SHARD_MSG",t))(Pc||{});const Lf=f.struct("Intent",{type:f.u8().transform({input:t=>t,output:t=>t}),version:f.u8(),appId:f.u8()}).transform({input:t=>({type:t,version:0,appId:3}),output:t=>t.type});function Gf(t){return f.struct(`ProtocolMessage<${t.name}>`,{intent:Lf,epoch:f.u32(),messageContents:t})}const Hf=f.enum("BlobPersistenceType",{Permanent:null,Deletable:f.struct("Deletable",{objectId:f.Address})}),qf=f.struct("StorageConfirmationBody",{blobId:yn,blobType:Hf}),Kf=Gf(qf);function Qf(...t){return f.struct("Field",{id:f.Address,name:t[0],value:t[1]})}const Ii=f.map(f.string(),f.string()).transform({input:t=>new Map([...t instanceof Map?t:Object.entries(t)].sort(([e],[n])=>Xf(f.string().serialize(e).toBytes(),f.string().serialize(n).toBytes()))),output:t=>Object.fromEntries(t)}),Jf=f.struct("QuiltPatchV1",{endIndex:f.u16(),identifier:f.string(),tags:Ii});function Xf(t,e){if(t.length!==e.length)return t.length-e.length;for(let n=0;n<t.length;n++)if(t[n]!==e[n])return t[n]-e[n];return 0}const Ls=f.struct("QuiltIndexV1",{patches:f.vector(Jf)}),Ti=f.struct("QuiltPatchId",{quiltId:yn,patchId:f.struct("InternalQuiltPatchId",{version:f.u8(),startIndex:f.u16(),endIndex:f.u16()})}),Uc=f.struct("QuiltPatchBlobHeader",{version:f.u8(),length:f.u32(),mask:f.u8()});var Rc=t=>{throw TypeError(t)},Yf=(t,e,n)=>e.has(t)||Rc("Cannot "+n),Zf=(t,e,n)=>e.has(t)?Rc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),ep=(t,e,n)=>(Yf(t,e,"access private method"),n),$i,Nc;class Dc extends Error{}const zc=class Gs extends Dc{constructor(e,n,r){var s;super(ep(s=Gs,$i,Nc).call(s,e,n,r)),this.status=e,this.error=n}static generate(e,n,r){return e?e===400?Oi.generate(e,n,r):e===401?new np(e,n,r):e===403?new rp(e,n,r):e===404?new pr(e,n,r):e===409?new sp(e,n,r):e===422?new ip(e,n,r):e===429?new ap(e,n,r):e===451?new Hs(e,n,r):e>=500?new op(e,n,r):new Gs(e,n,r):new tp({message:r})}};$i=new WeakSet;Nc=function(t,e,n){function r(a){return typeof a?.error?.message=="string"}const s=r(e)?e.error.message:n,i=s||JSON.stringify(e);return t&&i?`${t} ${i}`:i||(t?`${t} status code (no body)`:"(no status code or body)")};Zf(zc,$i);let ce=zc;class Lt extends ce{constructor({message:e}={}){super(void 0,void 0,e||"Request was aborted.")}}class tp extends ce{constructor({message:e}){super(void 0,void 0,e||"Connection error.")}}class Vc extends ce{constructor({message:e}={}){super(void 0,void 0,e??"Request timed out.")}}class Oi extends ce{static generate(e,n,r){return n&&typeof n=="object"&&"error"in n&&n.error.details?.[0]?.reason==="NOT_REGISTERED"?new Wc(n,r):new Oi(e,n,r)}}class Wc extends ce{constructor(e,n){super(400,e,n)}}class np extends ce{}class rp extends ce{}class pr extends ce{}class sp extends ce{}class ip extends ce{}class ap extends ce{}class Hs extends ce{}class op extends ce{}function tr(...t){const e=new Headers;for(const n of t)if(!(!n||typeof n!="object"))for(const[r,s]of Object.entries(n))if(s===null)e.delete(r);else if(Array.isArray(s))for(const i of s)e.append(r,i);else s!==void 0&&e.set(r,s);return e}var Fc=t=>{throw TypeError(t)},xi=(t,e,n)=>e.has(t)||Fc("Cannot "+n),Sn=(t,e,n)=>(xi(t,e,"read from private field"),n?n.call(t):e.get(t)),nr=(t,e,n)=>e.has(t)?Fc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),ps=(t,e,n,r)=>(xi(t,e,"write to private field"),e.set(t,n),n),At=(t,e,n)=>(xi(t,e,"access private method"),n),Dr,zr,un,rt,wt;class cp{constructor({fetch:e,timeout:n,onError:r}={}){nr(this,rt),nr(this,Dr),nr(this,zr),nr(this,un),ps(this,Dr,e??globalThis.fetch),ps(this,zr,n??3e4),ps(this,un,r)}async getBlobMetadata({blobId:e},n){const s=await(await At(this,rt,wt).call(this,`/v1/blobs/${e}/metadata`,{...n,headers:tr({Accept:"application/octet-stream"},n.headers)})).arrayBuffer();return Wf.parse(new Uint8Array(s))}async getBlobStatus({blobId:e},n){const i=(await(await At(this,rt,wt).call(this,`/v1/blobs/${e}/status`,n)).json()).success.data;if(i==="nonexistent")return{type:"nonexistent"};if("invalid"in i)return{type:"invalid",...i.invalid};if("permanent"in i)return{type:"permanent",...i.permanent};if("deletable"in i)return{type:"deletable",...i.deletable};throw new Dc(`Unknown blob status received: ${i}`)}async storeBlobMetadata({blobId:e,metadata:n},r){const i=typeof n=="object"&&"V1"in n?Bc.serialize(n).toBytes():n;return await(await At(this,rt,wt).call(this,`/v1/blobs/${e}/metadata`,{...r,method:"PUT",body:i,headers:tr({"Content-Type":"application/octet-stream"},r.headers)})).json()}async getSliver({blobId:e,sliverPairIndex:n,sliverType:r},s){const a=await(await At(this,rt,wt).call(this,`/v1/blobs/${e}/slivers/${n}/${r}`,{...s,headers:tr({Accept:"application/octet-stream"},s.headers)})).arrayBuffer();return Ot.parse(new Uint8Array(a))}async storeSliver({blobId:e,sliverPairIndex:n,sliverType:r,sliver:s},i){const o=typeof s=="object"&&"symbols"in s?Ot.serialize(s).toBytes():s;return await(await At(this,rt,wt).call(this,`/v1/blobs/${e}/slivers/${n}/${r}`,{...i,method:"PUT",body:o,headers:tr({"Content-Type":"application/octet-stream"},i.headers)})).json()}async getDeletableBlobConfirmation({blobId:e,objectId:n},r){return await(await At(this,rt,wt).call(this,`/v1/blobs/${e}/confirmation/deletable/${n}`,r)).json()}async getPermanentBlobConfirmation({blobId:e},n){return await(await At(this,rt,wt).call(this,`/v1/blobs/${e}/confirmation/permanent`,n)).json()}}Dr=new WeakMap;zr=new WeakMap;un=new WeakMap;rt=new WeakSet;wt=async function(t,e){var n,r,s;const{nodeUrl:i,signal:a,timeout:o,...c}=e;if(a?.aborted)throw new Lt;const l=AbortSignal.timeout(o??Sn(this,zr));let u;try{u=await Sn(this,Dr)(`${i}${t}`,{...c,signal:a?AbortSignal.any([l,a]):l})}catch(h){if(a?.aborted)throw new Lt;if(h instanceof Error&&h.name==="AbortError"){const g=new Vc;throw(n=Sn(this,un))==null||n.call(this,g),g}throw(r=Sn(this,un))==null||r.call(this,h),h}if(!u.ok){const h=await u.text().catch(b=>b),g=up(h),p=g?void 0:h,m=ce.generate(u.status,g,p);throw(s=Sn(this,un))==null||s.call(this,m),m}return u};function up(t){try{return JSON.parse(t)}catch{return}}const lp=32,dp=32,ba={RS2:2,RedStuff:2},ya={RS2:2**16-1,RedStuff:2**16-1};function gs(t,e,n="RS2"){const r=Lc(t,e,n),s=e*lp*2+dp;return e*s+r}function Lc(t,e,n="RS2"){const{primarySymbols:r,secondarySymbols:s}=gn(e,n);let i=Math.floor((Math.max(t,1)-1)/(r*s))+1;return n==="RS2"&&i%2===1&&(i=i+1),(r+s)*i*e}function gn(t,e="RS2"){const n=hp(t,e),r=ns(t),s=t-r;return{primarySymbols:s-r-n,secondarySymbols:s-n}}function kn(t,e){const n=ns(e);return t>2*n}function wa(t,e){const n=ns(e);return t>n}function ns(t){return Math.floor((t-1)/3)}function hp(t,e){switch(e){case"RedStuff":return Math.min(5,Math.floor(ns(t)/5));case"RS2":return 0;default:throw new Error(`Encountered unknown encoding type of ${e}`)}}const fp=1024*1024;function pp(t){return Math.ceil(t/fp)}function Gc(t,e){return t.reduce((n,r)=>(n*256+r)%e,0)}function ms(t,e,n){const r=Gc(yn.serialize(e).toBytes(),n);return(t+r)%n}function gp(t,e){return e-t-1}function mp(t,e,n){const r=Gc(yn.serialize(e).toBytes(),n);return(n+t-r)%n}function bp(t,e){const n=Math.ceil(e/8),r=new Uint8Array(n);for(const s of t){const i=Math.floor(s/8),a=s%8;r[i]|=1<<a}return r}function yp(t){const e=new Map;for(const n of t[0].contents)e.has(n.key)||e.set(n.key,[]),e.get(n.key).push(...n.value);return e}function xn(t){if(typeof t=="string")switch(t){case"Address":return"address";case"Bool":return"bool";case"U8":return"u8";case"U16":return"u16";case"U32":return"u32";case"U64":return"u64";case"U128":return"u128";case"U256":return"u256";default:throw new Error(`Unexpected type ${t}`)}if("Vector"in t)return`vector<${xn(t.Vector)}>`;if("Struct"in t)return t.Struct.typeArguments.length>0?`${t.Struct.address}::${t.Struct.module}::${t.Struct.name}<${t.Struct.typeArguments.map(xn).join(",")}>`:`${t.Struct.address}::${t.Struct.module}::${t.Struct.name}`;if("TypeParameter"in t)throw new Error("Type parameters can't be converted to type strings");if("Reference"in t)return xn(t.Reference);if("MutableReference"in t)return xn(t.MutableReference);throw new Error(`Unexpected type ${JSON.stringify(t)}`)}function Mi(t){return X(t).replace(/=*$/,"").replaceAll("+","-").replaceAll("/","_")}function Ai(t){return Q(t.replaceAll("-","+").replaceAll("_","/"))}function va(t,e){const n=Lc(t,e),{primarySymbols:r,secondarySymbols:s}=gn(e),i=(r+s)*e;if(n%i!==0)throw new Error("encoded blob size should be divisible by total symbols");const a=n/i;if(n%i!==0)throw new Error("blob length should be divisible by total symbols");const o=a*s,c=a*r;return{symbolSize:a,rowSize:o,columnSize:c,blobSize:t}}var bs,_a;function wp(){if(_a)return bs;_a=1;var t=(function(){function p(b,y){if(typeof b!="function")throw new TypeError("DataLoader must be constructed with a function which accepts "+("Array<key> and returns Promise<Array<value>>, but got: "+b+"."));this._batchLoadFn=b,this._maxBatchSize=o(y),this._batchScheduleFn=c(y),this._cacheKeyFn=l(y),this._cacheMap=u(y),this._batch=null,this.name=h(y)}var m=p.prototype;return m.load=function(y){if(y==null)throw new TypeError("The loader.load() function must be called with a value, "+("but got: "+String(y)+"."));var k=r(this),A=this._cacheMap,j;if(A){j=this._cacheKeyFn(y);var $=A.get(j);if($){var J=k.cacheHits||(k.cacheHits=[]);return new Promise(function(Ye){J.push(function(){Ye($)})})}}k.keys.push(y);var ve=new Promise(function(Ye,xe){k.callbacks.push({resolve:Ye,reject:xe})});return A&&A.set(j,ve),ve},m.loadMany=function(y){if(!g(y))throw new TypeError("The loader.loadMany() function must be called with Array<key> "+("but got: "+y+"."));for(var k=[],A=0;A<y.length;A++)k.push(this.load(y[A]).catch(function(j){return j}));return Promise.all(k)},m.clear=function(y){var k=this._cacheMap;if(k){var A=this._cacheKeyFn(y);k.delete(A)}return this},m.clearAll=function(){var y=this._cacheMap;return y&&y.clear(),this},m.prime=function(y,k){var A=this._cacheMap;if(A){var j=this._cacheKeyFn(y);if(A.get(j)===void 0){var $;k instanceof Error?($=Promise.reject(k),$.catch(function(){})):$=Promise.resolve(k),A.set(j,$)}}return this},p})(),e=typeof process=="object"&&typeof process.nextTick=="function"?function(p){n||(n=Promise.resolve()),n.then(function(){process.nextTick(p)})}:typeof setImmediate=="function"?function(p){setImmediate(p)}:function(p){setTimeout(p)},n;function r(p){var m=p._batch;if(m!==null&&!m.hasDispatched&&m.keys.length<p._maxBatchSize)return m;var b={hasDispatched:!1,keys:[],callbacks:[]};return p._batch=b,p._batchScheduleFn(function(){s(p,b)}),b}function s(p,m){if(m.hasDispatched=!0,m.keys.length===0){a(m);return}var b;try{b=p._batchLoadFn(m.keys)}catch(y){return i(p,m,new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function "+("errored synchronously: "+String(y)+".")))}if(!b||typeof b.then!="function")return i(p,m,new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did "+("not return a Promise: "+String(b)+".")));b.then(function(y){if(!g(y))throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did "+("not return a Promise of an Array: "+String(y)+"."));if(y.length!==m.keys.length)throw new TypeError("DataLoader must be constructed with a function which accepts Array<key> and returns Promise<Array<value>>, but the function did not return a Promise of an Array of the same length as the Array of keys."+(`

Keys:
`+String(m.keys))+(`

Values:
`+String(y)));a(m);for(var k=0;k<m.callbacks.length;k++){var A=y[k];A instanceof Error?m.callbacks[k].reject(A):m.callbacks[k].resolve(A)}}).catch(function(y){i(p,m,y)})}function i(p,m,b){a(m);for(var y=0;y<m.keys.length;y++)p.clear(m.keys[y]),m.callbacks[y].reject(b)}function a(p){if(p.cacheHits)for(var m=0;m<p.cacheHits.length;m++)p.cacheHits[m]()}function o(p){var m=!p||p.batch!==!1;if(!m)return 1;var b=p&&p.maxBatchSize;if(b===void 0)return 1/0;if(typeof b!="number"||b<1)throw new TypeError("maxBatchSize must be a positive number: "+b);return b}function c(p){var m=p&&p.batchScheduleFn;if(m===void 0)return e;if(typeof m!="function")throw new TypeError("batchScheduleFn must be a function: "+m);return m}function l(p){var m=p&&p.cacheKeyFn;if(m===void 0)return function(b){return b};if(typeof m!="function")throw new TypeError("cacheKeyFn must be a function: "+m);return m}function u(p){var m=!p||p.cache!==!1;if(!m)return null;var b=p&&p.cacheMap;if(b===void 0)return new Map;if(b!==null){var y=["get","set","delete","clear"],k=y.filter(function(A){return b&&typeof b[A]!="function"});if(k.length!==0)throw new TypeError("Custom cacheMap missing methods: "+k.join(", "))}return b}function h(p){return p&&p.name?p.name:null}function g(p){return typeof p=="object"&&p!==null&&typeof p.length=="number"&&(p.length===0||p.length>0&&Object.prototype.hasOwnProperty.call(p,p.length-1))}return bs=t,bs}var vp=wp();const _p=yu(vp);var Hc=t=>{throw TypeError(t)},Sp=(t,e,n)=>e.has(t)||Hc("Cannot "+n),Sa=(t,e,n)=>(Sp(t,e,"read from private field"),n?n.call(t):e.get(t)),kp=(t,e,n)=>e.has(t)?Hc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),gr;class Ep extends _p{constructor(e){super(async n=>{const{objects:r}=await e.core.getObjects({objectIds:n});return r}),kp(this,gr,new Map)}async load(e,n){const r=await super.load(e);return n?n.parse(await r.content):r}async loadMany(e,n){const r=await super.loadMany(e);return n?Promise.all(r.map(async s=>s instanceof Error?s:n.parse(await s.content))):r}async loadManyOrThrow(e,n){const r=await this.loadMany(e,n);for(const s of r)if(s instanceof Error)throw s;return r}clearAll(){return Sa(this,gr).clear(),super.clearAll()}clear(e){return Sa(this,gr).delete(e),super.clear(e)}async loadFieldObject(e,n,r){const s=on(n.type),i=zo(e,"u64",s.serialize(n.value).toBytes());return(await this.load(i,Qf(s,r))).value}}gr=new WeakMap;function Ip(t){return t.map(({value:e,weight:n})=>({value:e,weight:Math.pow(Math.random(),1/n)})).sort((e,n)=>n.weight-e.weight).map(e=>e.value)}function Tp(t){const e=[...t];for(let n=e.length-1;n>0;n-=1){const r=Math.floor(Math.random()*(n+1));[e[n],e[r]]=[e[r],e[n]]}return e}let B,Le=0,Mn=null;function ln(){return(Mn===null||Mn.byteLength===0)&&(Mn=new Uint8Array(B.memory.buffer)),Mn}const mr=typeof TextEncoder<"u"?new TextEncoder("utf-8"):{encode:()=>{throw Error("TextEncoder not available")}},$p=typeof mr.encodeInto=="function"?function(t,e){return mr.encodeInto(t,e)}:function(t,e){const n=mr.encode(t);return e.set(n),{read:t.length,written:n.length}};function ys(t,e,n){if(n===void 0){const o=mr.encode(t),c=e(o.length,1)>>>0;return ln().subarray(c,c+o.length).set(o),Le=o.length,c}let r=t.length,s=e(r,1)>>>0;const i=ln();let a=0;for(;a<r;a++){const o=t.charCodeAt(a);if(o>127)break;i[s+a]=o}if(a!==r){a!==0&&(t=t.slice(a)),s=n(s,r,r=a+t.length*3,1)>>>0;const o=ln().subarray(s+a,s+r),c=$p(t,o);a+=c.written,s=n(s,r,a,1)>>>0}return Le=a,s}let Ct=null;function gt(){return(Ct===null||Ct.buffer.detached===!0||Ct.buffer.detached===void 0&&Ct.buffer!==B.memory.buffer)&&(Ct=new DataView(B.memory.buffer)),Ct}function Op(t){const e=B.__externref_table_alloc();return B.__wbindgen_export_4.set(e,t),e}function ws(t,e){try{return t.apply(this,e)}catch(n){const r=Op(n);B.__wbindgen_exn_store(r)}}function qs(t){const e=typeof t;if(e=="number"||e=="boolean"||t==null)return`${t}`;if(e=="string")return`"${t}"`;if(e=="symbol"){const s=t.description;return s==null?"Symbol":`Symbol(${s})`}if(e=="function"){const s=t.name;return typeof s=="string"&&s.length>0?`Function(${s})`:"Function"}if(Array.isArray(t)){const s=t.length;let i="[";s>0&&(i+=qs(t[0]));for(let a=1;a<s;a++)i+=", "+qs(t[a]);return i+="]",i}const n=/\[object ([^\]]+)\]/.exec(toString.call(t));let r;if(n&&n.length>1)r=n[1];else return toString.call(t);if(r=="Object")try{return"Object("+JSON.stringify(t)+")"}catch{return"Object"}return t instanceof Error?`${t.name}: ${t.message}
${t.stack}`:r}const qc=typeof TextDecoder<"u"?new TextDecoder("utf-8",{ignoreBOM:!0,fatal:!0}):{decode:()=>{throw Error("TextDecoder not available")}};typeof TextDecoder<"u"&&qc.decode();function vs(t,e){return t=t>>>0,qc.decode(ln().subarray(t,t+e))}function _s(t){return t==null}function Un(t,e){const n=e(t.length*1,1)>>>0;return ln().set(t,n/1),Le=t.length,n}function it(t){const e=B.__wbindgen_export_4.get(t);return B.__externref_table_dealloc(t),e}function xp(t,e,n){const r=Un(t,B.__wbindgen_malloc),s=Le,i=Un(e,B.__wbindgen_malloc),a=Le,o=Un(n,B.__wbindgen_malloc),c=Le,l=B.bls12381_min_pk_verify(r,s,i,a,o,c);if(l[2])throw it(l[1]);return l[0]!==0}function Mp(t,e){return t=t>>>0,ln().subarray(t/1,t/1+e)}function Ap(t){const e=B.bls12381_min_pk_aggregate(t);if(e[3])throw it(e[2]);var n=Mp(e[0],e[1]).slice();return B.__wbindgen_free(e[0],e[1]*1,1),n}const ka=typeof FinalizationRegistry>"u"?{register:()=>{},unregister:()=>{}}:new FinalizationRegistry(t=>B.__wbg_blobencoder_free(t>>>0,1));class Ss{__destroy_into_raw(){const e=this.__wbg_ptr;return this.__wbg_ptr=0,ka.unregister(this),e}free(){const e=this.__destroy_into_raw();B.__wbg_blobencoder_free(e,0)}constructor(e){const n=B.blobencoder_new(e);if(n[2])throw it(n[1]);return this.__wbg_ptr=n[0]>>>0,ka.register(this,this.__wbg_ptr,this),this}encode_with_metadata(e){const n=Un(e,B.__wbindgen_malloc),r=Le,s=B.blobencoder_encode_with_metadata(this.__wbg_ptr,n,r);if(s[2])throw it(s[1]);return it(s[0])}compute_metadata(e){const n=Un(e,B.__wbindgen_malloc),r=Le,s=B.blobencoder_compute_metadata(this.__wbg_ptr,n,r);if(s[2])throw it(s[1]);return it(s[0])}decode(e,n,r){const s=B.blobencoder_decode(this.__wbg_ptr,e,n,r);if(s[2])throw it(s[1]);return it(s[0])}}async function Bp(t,e){if(typeof Response=="function"&&t instanceof Response){if(typeof WebAssembly.instantiateStreaming=="function")try{return await WebAssembly.instantiateStreaming(t,e)}catch(r){if(t.headers.get("Content-Type")!="application/wasm")console.warn("`WebAssembly.instantiateStreaming` failed because your server does not serve Wasm with `application/wasm` MIME type. Falling back to `WebAssembly.instantiate` which is slower. Original error:\n",r);else throw r}const n=await t.arrayBuffer();return await WebAssembly.instantiate(n,e)}else{const n=await WebAssembly.instantiate(t,e);return n instanceof WebAssembly.Instance?{instance:n,module:t}:n}}function Cp(){const t={};return t.wbg={},t.wbg.__wbg_String_fed4d24b68977888=function(e,n){const r=String(n),s=ys(r,B.__wbindgen_malloc,B.__wbindgen_realloc),i=Le;gt().setInt32(e+4,i,!0),gt().setInt32(e+0,s,!0)},t.wbg.__wbg_buffer_609cc3eee51ed158=function(e){return e.buffer},t.wbg.__wbg_call_672a4d21634d4a24=function(){return ws(function(e,n){return e.call(n)},arguments)},t.wbg.__wbg_done_769e5ede4b31c67b=function(e){return e.done},t.wbg.__wbg_get_67b2ba62fc30de12=function(){return ws(function(e,n){return Reflect.get(e,n)},arguments)},t.wbg.__wbg_get_b9b93047fe3cf45b=function(e,n){return e[n>>>0]},t.wbg.__wbg_getwithrefkey_bb8f74a92cb2e784=function(e,n){return e[n]},t.wbg.__wbg_instanceof_ArrayBuffer_e14585432e3737fc=function(e){let n;try{n=e instanceof ArrayBuffer}catch{n=!1}return n},t.wbg.__wbg_instanceof_Uint8Array_17156bcf118086a9=function(e){let n;try{n=e instanceof Uint8Array}catch{n=!1}return n},t.wbg.__wbg_isArray_a1eab7e0d067391b=function(e){return Array.isArray(e)},t.wbg.__wbg_isSafeInteger_343e2beeeece1bb0=function(e){return Number.isSafeInteger(e)},t.wbg.__wbg_iterator_9a24c88df860dc65=function(){return Symbol.iterator},t.wbg.__wbg_length_a446193dc22c12f8=function(e){return e.length},t.wbg.__wbg_length_e2d2a49132c1b256=function(e){return e.length},t.wbg.__wbg_new_405e22f390576ce2=function(){return new Object},t.wbg.__wbg_new_78feb108b6472713=function(){return new Array},t.wbg.__wbg_new_a12002a7f91c75be=function(e){return new Uint8Array(e)},t.wbg.__wbg_next_25feadfc0913fea9=function(e){return e.next},t.wbg.__wbg_next_6574e1a8a62d1055=function(){return ws(function(e){return e.next()},arguments)},t.wbg.__wbg_set_37837023f3d740e8=function(e,n,r){e[n>>>0]=r},t.wbg.__wbg_set_3fda3bac07393de4=function(e,n,r){e[n]=r},t.wbg.__wbg_set_65595bdd868b3009=function(e,n,r){e.set(n,r>>>0)},t.wbg.__wbg_value_cd1ffa7b1ab794f1=function(e){return e.value},t.wbg.__wbindgen_bigint_from_u64=function(e){return BigInt.asUintN(64,e)},t.wbg.__wbindgen_boolean_get=function(e){const n=e;return typeof n=="boolean"?n?1:0:2},t.wbg.__wbindgen_debug_string=function(e,n){const r=qs(n),s=ys(r,B.__wbindgen_malloc,B.__wbindgen_realloc),i=Le;gt().setInt32(e+4,i,!0),gt().setInt32(e+0,s,!0)},t.wbg.__wbindgen_error_new=function(e,n){return new Error(vs(e,n))},t.wbg.__wbindgen_in=function(e,n){return e in n},t.wbg.__wbindgen_init_externref_table=function(){const e=B.__wbindgen_export_4,n=e.grow(4);e.set(0,void 0),e.set(n+0,void 0),e.set(n+1,null),e.set(n+2,!0),e.set(n+3,!1)},t.wbg.__wbindgen_is_function=function(e){return typeof e=="function"},t.wbg.__wbindgen_is_object=function(e){const n=e;return typeof n=="object"&&n!==null},t.wbg.__wbindgen_is_undefined=function(e){return e===void 0},t.wbg.__wbindgen_jsval_loose_eq=function(e,n){return e==n},t.wbg.__wbindgen_memory=function(){return B.memory},t.wbg.__wbindgen_number_get=function(e,n){const r=n,s=typeof r=="number"?r:void 0;gt().setFloat64(e+8,_s(s)?0:s,!0),gt().setInt32(e+0,!_s(s),!0)},t.wbg.__wbindgen_number_new=function(e){return e},t.wbg.__wbindgen_string_get=function(e,n){const r=n,s=typeof r=="string"?r:void 0;var i=_s(s)?0:ys(s,B.__wbindgen_malloc,B.__wbindgen_realloc),a=Le;gt().setInt32(e+4,a,!0),gt().setInt32(e+0,i,!0)},t.wbg.__wbindgen_string_new=function(e,n){return vs(e,n)},t.wbg.__wbindgen_throw=function(e,n){throw new Error(vs(e,n))},t}function jp(t,e){return B=t.exports,Kc.__wbindgen_wasm_module=e,Ct=null,Mn=null,B.__wbindgen_start(),B}async function Kc(t){if(B!==void 0)return B;typeof t<"u"&&(Object.getPrototypeOf(t)===Object.prototype?{module_or_path:t}=t:console.warn("using deprecated parameters for the initialization function; pass a single object instead")),typeof t>"u"&&(t=new URL("/assets/walrus_wasm_bg-KCYZ1fvy.wasm",import.meta.url));const e=Cp();(typeof t=="string"||typeof Request=="function"&&t instanceof Request||typeof URL=="function"&&t instanceof URL)&&(t=fetch(t));const{instance:n,module:r}=await Bp(await t,e);return jp(n,r)}async function Pp(t){await Kc({module_or_path:t});function e(a,o,c="RS2"){const l=new Ss(a);if(c!=="RS2")throw new Error(`Unsupported encoding type: ${c}`);const[u,h,g]=l.encode_with_metadata(o);return{sliverPairs:u,blobId:ma(new Uint8Array(h.blob_id)),metadata:h.metadata,rootHash:new Uint8Array(g.Digest)}}function n(a,o){const c=Ap(a.map(l=>Q(l.signature)));return{signers:o,serializedMessage:Q(a[0].serializedMessage),signature:c}}function r(a,o,c,l,u="RS2"){const h=new Ss(o);if(u!=="RS2")throw new Error(`Unsupported encoding type: ${u}`);const[g]=h.decode(yn.serialize(a).toBytes(),BigInt(c),l.map(p=>({...p,_sliver_type:void 0})));return new Uint8Array(g)}function s(){return(a,o)=>xp(Q(a.signature),o,Q(a.serializedMessage))}function i(a,o,c="RS2"){const l=new Ss(a),[u,h]=l.compute_metadata(o);if(c!=="RS2")throw new Error(`Unsupported encoding type: ${c}`);return{...u,blobId:ma(new Uint8Array(u.blob_id)),rootHash:new Uint8Array(h.Digest)}}return{encodeBlob:e,combineSignatures:n,decodePrimarySlivers:r,getVerifySignature:s,computeMetadata:i}}var Qc=t=>{throw TypeError(t)},Bi=(t,e,n)=>e.has(t)||Qc("Cannot "+n),En=(t,e,n)=>(Bi(t,e,"read from private field"),n?n.call(t):e.get(t)),rr=(t,e,n)=>e.has(t)?Qc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),ks=(t,e,n,r)=>(Bi(t,e,"write to private field"),e.set(t,n),n),Ea=(t,e,n)=>(Bi(t,e,"access private method"),n),Vr,Wr,dn,br,Ks;class Up{constructor({host:e,fetch:n,timeout:r,onError:s}){rr(this,br),rr(this,Vr),rr(this,Wr),rr(this,dn),this.host=e,ks(this,Vr,n??globalThis.fetch),ks(this,Wr,r??3e4),ks(this,dn,s)}async tipConfig(){const n=await(await Ea(this,br,Ks).call(this,{method:"GET",path:"/v1/tip-config"})).json();return typeof n=="string"?null:"const"in n.send_tip.kind?{address:n.send_tip.address,kind:{const:n.send_tip.kind.const}}:{address:n.send_tip.address,kind:{linear:{base:n.send_tip.kind.linear.base,perEncodedKib:n.send_tip.kind.linear.encoded_size_mul_per_kib}}}}async writeBlob({blobId:e,nonce:n,txDigest:r,blob:s,deletable:i,blobObjectId:a,requiresTip:o,encodingType:c,...l}){const u=new URLSearchParams({blob_id:e});o&&(u.set("nonce",Mi(n)),u.set("tx_id",r)),i&&u.set("deletable_blob_object",a),c&&u.set("encoding_type",c);const g=await(await Ea(this,br,Ks).call(this,{method:"POST",path:`/v1/blob-upload-relay?${u.toString()}`,body:s,...l})).json();return{blobId:e,certificate:{signers:g.confirmation_certificate.signers,serializedMessage:new Uint8Array(g.confirmation_certificate.serialized_message),signature:Ai(g.confirmation_certificate.signature)}}}}Vr=new WeakMap;Wr=new WeakMap;dn=new WeakMap;br=new WeakSet;Ks=async function(t){var e,n,r;const{signal:s,timeout:i,...a}=t;if(s?.aborted)throw new Lt;const o=AbortSignal.timeout(i??En(this,Wr));let c;try{c=await En(this,Vr)(`${this.host}${t.path}`,{...a,signal:s?AbortSignal.any([o,s]):o})}catch(l){if(s?.aborted)throw new Lt;if(l instanceof Error&&l.name==="AbortError"){const u=new Vc;throw(e=En(this,dn))==null||e.call(this,u),u}throw(n=En(this,dn))==null||n.call(this,l),l}if(!c.ok){const l=await c.text().catch(p=>p),u=Rp(l),h=u?void 0:l,g=ce.generate(c.status,u,h);throw(r=En(this,dn))==null||r.call(this,g),g}return c};function Rp(t){try{return JSON.parse(t)}catch{return}}const Np=4,Dp=1,yr=Dp+Np,Fr=6,Qs=2,Ia=2,zp=(1<<8*Qs)-1,Ta=10,Jc=1;function Vp(t,e,n,r,s="RS2"){if(t.length>e)throw new Error("Too many blobs, the number of blobs must be less than the number of columns");if(t.length===0)throw new Error("No blobs provided");let i=Math.max(t.reduce((c,l)=>c+l,0)/(e*n),t[0]/(n*r),Math.ceil(yr/n)),a=Math.ceil(Math.max(...t)/(e/t.length)*n);for(;i<a;){const c=(i+a)/2;$a(t,e,c*n)?a=c:i=c+1}const o=Math.ceil(i/ba[s])*ba[s];if(!$a(t,e,o*n))throw new Error("Quilt oversize");if(o>ya[s])throw new Error(`Quilt oversize: the resulting symbol size ${o} is larger than the maximum symbol size ${ya[s]}; remove some blobs`);return o}function $a(t,e,n){return t.reduce((r,s)=>r+Math.ceil(s/n),0)<=e}function Xc(t){return Ti.parse(Ai(t))}function Oa(t){return Mi(Ti.serialize(t).toBytes())}function Wp(t){return Ai(t).length===32?{kind:"blob",id:t}:{kind:"quiltPatch",id:Xc(t)}}function Fp({blobs:t,numShards:e,encodingType:n}){const{primarySymbols:r,secondarySymbols:s}=gn(e,n),i=t.sort(($,J)=>$.identifier<J.identifier?-1:1),a=new Set,o={patches:[]},c=i.map($=>$.tags&&Object.keys($.tags).length>0?Ii.serialize($.tags).toBytes():null);for(const $ of i){if(a.has($.identifier))throw new Error(`Duplicate blob identifier: ${$.identifier}`);a.add($.identifier),o.patches.push({startIndex:0,endIndex:0,identifier:$.identifier,tags:$.tags??{}})}const l=yr+Ls.serialize(o).toBytes().length,u=i.map(($,J)=>{const ve=d.string().serialize($.identifier).toBytes();let Ye=Fr+Qs+ve.length,xe=0,_e=0;c[J]&&(Ye+=Ia+c[J].length,xe|=Jc<<0);const Jt=new Uint8Array(Ye),ht=new DataView(Jt.buffer),Di=Uc.serialize({version:1,length:Ye-Fr+$.contents.length,mask:xe}).toBytes();return Jt.set(Di,_e),_e+=Di.length,ht.setUint16(_e,ve.length,!0),_e+=Qs,Jt.set(ve,_e),_e+=ve.length,c[J]&&(ht.setUint16(_e,c[J].length,!0),_e+=Ia,Jt.set(c[J],_e),_e+=c[J].length),Jt}),h=[l,...i.map(($,J)=>{if($.identifier.length>zp)throw new Error(`Blob identifier too long: ${$.identifier}`);return u[J].length+$.contents.length})],g=Vp(h,s,r,Ta,n),p=g*s,m=g*r,b=Math.ceil(l/m);if(b>Ta)throw new Error("Index too large");const y=new Uint8Array(p*r);let k=b;for(let $=0;$<i.length;$++){const J=i[$];o.patches[$].startIndex=k,k+=xa(y,J.contents,p,m,g,k,u[$]),o.patches[$].endIndex=k}const A=Ls.serialize(o).toBytes(),j=new Uint8Array(yr+A.length);return j.set([1],0),j.set(new Uint32Array([A.length]),1),j.set(A,yr),xa(y,j,p,m,g,0),{quilt:y,index:o}}function xa(t,e,n,r,s,i,a){const o=r/s;let c=0;if(n%s!==0)throw new Error("Row size must be divisible by symbol size");if(r%s!==0)throw new Error("Column size must be divisible by symbol size");return a&&l(a),l(e),Math.ceil(c/r);function l(u){const h=c,g=Math.floor(h/s);let p=h%s,m=i+Math.floor(g/o),b=g%o,y=0;for(;y<u.length;){const A=b*n+m*s+p,j=Math.min(s-p,u.length-y);for(let $=0;$<j;$++)t[A+$]=u[y+$];y+=j,p=0,b=(b+1)%o,b===0&&m++}c+=u.length}}var Yc=t=>{throw TypeError(t)},Zc=(t,e,n)=>e.has(t)||Yc("Cannot "+n),Se=(t,e,n)=>(Zc(t,e,"read from private field"),n?n.call(t):e.get(t)),sr=(t,e,n)=>e.has(t)?Yc("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),mt=(t,e,n,r)=>(Zc(t,e,"write to private field"),e.set(t,n),n),tn,nn,vt,_t;class Js{constructor({quilt:e,sliverIndex:n,identifier:r,tags:s}){sr(this,tn),sr(this,nn),sr(this,vt),sr(this,_t),mt(this,tn,e),mt(this,nn,n),mt(this,vt,r??null),mt(this,_t,s)}async getBytes(){const{blobContents:e,identifier:n,tags:r}=await Se(this,tn).readBlob(Se(this,nn));return mt(this,vt,n),mt(this,_t,r??{}),e}async getIdentifier(){if(Se(this,vt)!==null)return Se(this,vt);const e=await Se(this,tn).getBlobHeader(Se(this,nn));return mt(this,vt,e.identifier),Se(this,vt)}async getTags(){if(Se(this,_t)!==void 0)return Se(this,_t);const e=await Se(this,tn).getBlobHeader(Se(this,nn));return mt(this,_t,e.tags??{}),Se(this,_t)}}tn=new WeakMap;nn=new WeakMap;vt=new WeakMap;_t=new WeakMap;var eu=t=>{throw TypeError(t)},Ci=(t,e,n)=>e.has(t)||eu("Cannot "+n),Oe=(t,e,n)=>(Ci(t,e,"read from private field"),n?n.call(t):e.get(t)),Es=(t,e,n)=>e.has(t)?eu("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),Lp=(t,e,n,r)=>(Ci(t,e,"write to private field"),e.set(t,n),n),Pe=(t,e,n)=>(Ci(t,e,"access private method"),n),fe,Xs,ye,tu,Ys,st;class nu{constructor({blob:e}){Es(this,ye),Es(this,fe),Es(this,Xs,new Zr),Lp(this,fe,e)}async getBlobHeader(e){return Oe(this,Xs).read(["getBlobHeader",e.toString()],async()=>{const n=Uc.parse(await Pe(this,ye,st).call(this,e,Fr));let r=Fr,s=n.length;const i=new DataView((await Pe(this,ye,st).call(this,e,2,r)).buffer).getUint16(0,!0);s-=2+i,r+=2;const a=d.string().parse(await Pe(this,ye,st).call(this,e,i,r));r+=i;let o=null;if(n.mask&Jc){const c=new DataView((await Pe(this,ye,st).call(this,e,2,r)).buffer).getUint16(0,!0);r+=2,o=Ii.parse(await Pe(this,ye,st).call(this,e,c,r)),s-=c+2,r+=c}return{identifier:a,tags:o,blobSize:s,contentOffset:r}})}async readBlob(e){const{identifier:n,tags:r,blobSize:s,contentOffset:i}=await this.getBlobHeader(e),a=await Pe(this,ye,st).call(this,e,s,i);return{identifier:n,tags:r,blobContents:a}}readerForPatchId(e){const{quiltId:n,patchId:r}=Xc(e);if(n!==Oe(this,fe).blobId)throw new Error(`The requested patch ${r} is not part of the quilt ${Oe(this,fe).blobId}`);return new Js({quilt:this,sliverIndex:r.startIndex})}async readIndex(){const e=new DataView((await Pe(this,ye,st).call(this,0,5)).buffer),n=e.getUint8(0);if(n!==1)throw new Error(`Unsupported quilt version ${n}`);const r=e.getUint32(1,!0),s=await Pe(this,ye,st).call(this,0,r,5),i=await Oe(this,fe).getColumnSize(),a=Math.ceil(r/i),o=Ls.parse(s);return o.patches.map((c,l)=>{const u=l===0?a:o.patches[l-1].endIndex,h=new Js({quilt:this,sliverIndex:u,identifier:c.identifier,tags:c.tags});return{identifier:c.identifier,patchId:Mi(Ti.serialize({quiltId:Oe(this,fe).blobId,patchId:{version:1,startIndex:u,endIndex:c.endIndex}}).toBytes()),tags:c.tags,reader:h}})}}fe=new WeakMap;Xs=new WeakMap;ye=new WeakSet;tu=async function(t,e,n=0,r){if(!e)return new Uint8Array(0);Oe(this,fe).getSecondarySliver({sliverIndex:t}).catch(()=>{}),r=r??await Oe(this,fe).getColumnSize();const s=Math.floor(n/r);let i=n%r;const a=new Uint8Array(e);let o=0;const c=Math.ceil(e/r),l=new Array(c).fill(0).map((u,h)=>Oe(this,fe).getSecondarySliver({sliverIndex:t+s+h}));l.forEach(u=>u.catch(()=>{}));for(const u of l){const h=await u;let g=i>0?h.subarray(i):h;if(i-=g.length,g.length>e-o&&(g=g.subarray(0,e-o)),a.set(g,o),o+=g.length,o>=e)break}return a};Ys=async function(t,e,n=0){const r=new Uint8Array(e);if(!e)return r;const s=await Oe(this,fe).getBytes(),[i,a]=await Promise.all([Oe(this,fe).getRowSize(),Oe(this,fe).getSymbolSize()]),o=s.length/i,c=Math.floor(n/a);let l=n%a,u=t+Math.floor(c/o),h=c%o,g=0;for(;g<e;){const p=h*i+u*a,m=p+l,b=Math.min(p+a,m+e-g,s.length);if(m>=s.length)throw new Error("Index out of bounds");const y=b-m;for(let k=0;k<y;k++)r[g+k]=s[m+k];g+=y,l=0,h=(h+1)%o,h===0&&(u+=1)}return r};st=async function(t,e,n=0,r){if(Oe(this,fe).hasStartedLoadingFullBlob)return Pe(this,ye,Ys).call(this,t,e,n);try{return await Pe(this,ye,tu).call(this,t,e,n,r)}catch{return Pe(this,ye,Ys).call(this,t,e,n)}};var ru=t=>{throw TypeError(t)},su=(t,e,n)=>e.has(t)||ru("Cannot "+n),te=(t,e,n)=>(su(t,e,"read from private field"),n?n.call(t):e.get(t)),ir=(t,e,n)=>e.has(t)?ru("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),Ma=(t,e,n,r)=>(su(t,e,"write to private field"),e.set(t,n),n),An,rn,St,jt;class Aa{constructor({client:e,blobId:n,numShards:r}){ir(this,An,new Zr),ir(this,rn),ir(this,St,new Map),this.hasStartedLoadingFullBlob=!1,ir(this,jt),Ma(this,rn,e),this.blobId=n,Ma(this,jt,r)}async getIdentifier(){return null}async getTags(){return{}}getQuiltReader(){return new nu({blob:this})}async getBytes(){return te(this,An).read(["getBytes"],async()=>{this.hasStartedLoadingFullBlob=!0;try{return await te(this,rn).readBlob({blobId:this.blobId})}catch(e){throw this.hasStartedLoadingFullBlob=!1,e}})}getMetadata(){return te(this,An).read(["getMetadata"],()=>te(this,rn).getBlobMetadata({blobId:this.blobId}))}async getColumnSize(){return te(this,An).read(["getColumnSize"],async()=>{const e=[...te(this,St).values()];if(e.length>0){const s=await Promise.any(e).catch(()=>null);if(s)return s.length}if(this.hasStartedLoadingFullBlob){const s=await this.getBytes(),{columnSize:i}=va(s.length,te(this,jt));return i}const n=await this.getMetadata(),{columnSize:r}=va(Number(n.metadata.V1.unencoded_length),te(this,jt));return r})}async getSymbolSize(){const e=await this.getColumnSize(),{primarySymbols:n}=gn(te(this,jt));if(e%n!==0)throw new Error("column size should be divisible by primary symbols");return e/n}async getRowSize(){const e=await this.getSymbolSize(),{secondarySymbols:n}=gn(te(this,jt));return e*n}async getSecondarySliver({sliverIndex:e,signal:n}){if(te(this,St).has(e))return te(this,St).get(e);const r=te(this,rn).getSecondarySliver({blobId:this.blobId,index:e,signal:n}).then(s=>new Uint8Array(s.symbols.data));te(this,St).set(e,r);try{const s=await r;return te(this,St).set(e,s),s}catch(s){throw te(this,St).delete(e),s}}}An=new WeakMap;rn=new WeakMap;St=new WeakMap;jt=new WeakMap;var iu=t=>{throw TypeError(t)},au=(t,e,n)=>e.has(t)||iu("Cannot "+n),In=(t,e,n)=>(au(t,e,"read from private field"),n?n.call(t):e.get(t)),Is=(t,e,n)=>e.has(t)?iu("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),Ts=(t,e,n,r)=>(au(t,e,"write to private field"),e.set(t,n),n),sn,wr,vr;class Gp{constructor({contents:e,identifier:n,tags:r}){Is(this,sn),Is(this,wr),Is(this,vr),Ts(this,sn,e),Ts(this,wr,n??null),Ts(this,vr,r??{})}async getBytes(){return"arrayBuffer"in In(this,sn)?new Uint8Array(await In(this,sn).arrayBuffer()):In(this,sn)}async getIdentifier(){return In(this,wr)}async getTags(){return In(this,vr)}}sn=new WeakMap;wr=new WeakMap;vr=new WeakMap;var ou=t=>{throw TypeError(t)},cu=(t,e,n)=>e.has(t)||ou("Cannot "+n),$s=(t,e,n)=>(cu(t,e,"read from private field"),n?n.call(t):e.get(t)),Hp=(t,e,n)=>e.has(t)?ou("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),qp=(t,e,n,r)=>(cu(t,e,"write to private field"),e.set(t,n),n),an;const Kp=class uu{constructor({reader:e}){Hp(this,an),qp(this,an,e)}static from(e){return new uu({reader:new Gp(e)})}getIdentifier(){return $s(this,an).getIdentifier()}getTags(){return $s(this,an).getTags()}bytes(){return $s(this,an).getBytes()}async text(){const e=await this.bytes();return new TextDecoder().decode(e)}async json(){return JSON.parse(await this.text())}};an=new WeakMap;let Lr=Kp;var lu=t=>{throw TypeError(t)},ji=(t,e,n)=>e.has(t)||lu("Cannot "+n),Vt=(t,e,n)=>(ji(t,e,"read from private field"),n?n.call(t):e.get(t)),ar=(t,e,n)=>e.has(t)?lu("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),Ba=(t,e,n,r)=>(ji(t,e,"write to private field"),e.set(t,n),n),Ca=(t,e,n)=>(ji(t,e,"access private method"),n),Tt,Gr,Pi,_r,Zs;class Qp{constructor({reader:e,client:n}){ar(this,_r),ar(this,Tt),ar(this,Gr),ar(this,Pi,new Zr),Ba(this,Tt,e),Ba(this,Gr,n)}asFile(){return new Lr({reader:Vt(this,Tt)})}async blobId(){return Vt(this,Tt).blobId}async files(e={}){const n=await Vt(this,Tt).getQuiltReader(),r=await n.readIndex(),s=[];for(const i of r)e.ids&&!e.ids.includes(i.patchId)||e.identifiers&&!e.identifiers.includes(i.identifier)||e.tags&&!e.tags.some(a=>Object.entries(a).every(([o,c])=>i.tags[o]===c))||s.push(new Lr({reader:n.readerForPatchId(i.patchId)}));return s}async exists(){const e=await Ca(this,_r,Zs).call(this);return e.type==="permanent"||e.type==="deletable"}async storedUntil(){const e=await Ca(this,_r,Zs).call(this);return e.type==="permanent"?e.endEpoch:null}}Tt=new WeakMap;Gr=new WeakMap;Pi=new WeakMap;_r=new WeakSet;Zs=async function(){return Vt(this,Pi).read(["blobStatus",Vt(this,Tt).blobId],()=>Vt(this,Gr).getVerifiedBlobStatus({blobId:Vt(this,Tt).blobId}))};async function Jp(t,e){let n=e.count??3;for(;n>0;)try{return n-=1,await t()}catch(r){if(n<=0||e.condition&&!e.condition(r))throw r;await new Promise(s=>setTimeout(s,e.delay+(e.jitter?Math.random()*e.jitter:0)))}throw new Error("Retry count exceeded")}var du=t=>{throw TypeError(t)},Ui=(t,e,n)=>e.has(t)||du("Cannot "+n),S=(t,e,n)=>(Ui(t,e,"read from private field"),e.get(t)),Me=(t,e,n)=>e.has(t)?du("Cannot add the same private member more than once"):e instanceof WeakSet?e.add(t):e.set(t,n),Be=(t,e,n,r)=>(Ui(t,e,"write to private field"),e.set(t,n),n),T=(t,e,n)=>(Ui(t,e,"access private method"),n),Ce,Hr,ue,le,me,ei,Rn,Fe,ze,ae,I,hu,Ri,Ut,Nn,fu,pu,ti,gu,Sr,ni,ri,si,Pt,Ni,qe,mu,kr,ii;const Xp=class bu{constructor(e){if(Me(this,I),Me(this,Ce),Me(this,Hr),Me(this,ue),Me(this,le),Me(this,me),Me(this,ei,10),Me(this,Rn),Me(this,Fe),Me(this,ze,null),Me(this,ae,null),this.readBlob=T(this,I,ii).call(this,T(this,I,fu)),this.getSecondarySliver=T(this,I,ii).call(this,this.internalGetSecondarySliver),e.network&&!e.packageConfig){const n=e.network;switch(n){case"testnet":Be(this,ue,Rh);break;case"mainnet":Be(this,ue,Nh);break;default:throw new re(`Unsupported network: ${n}`)}}else Be(this,ue,e.packageConfig);Be(this,Hr,e.wasmUrl),Be(this,ze,e.uploadRelay??null),S(this,ze)&&Be(this,ae,new Up(S(this,ze))),Be(this,le,e.suiClient??new Uh({url:e.suiRpcUrl})),Be(this,Ce,new cp(e.storageNodeClientOptions)),Be(this,me,new Ep(S(this,le))),Be(this,Fe,S(this,le).cache.scope("@mysten/walrus"))}static experimental_asClientExtension({packageConfig:e,network:n,...r}={}){return{name:"walrus",register:s=>{const i=n||s.network;if(i!=="mainnet"&&i!=="testnet")throw new re("Walrus client only supports mainnet and testnet");return new bu(e?{packageConfig:e,suiClient:s,...r}:{network:i,suiClient:s,...r})}}}getBlobType(){return S(this,Fe).read(["getBlobType"],async()=>`${await T(this,I,Ri).call(this)}::blob::Blob`)}systemObject(){return S(this,me).load(S(this,ue).systemObjectId,$f)}stakingObject(){return S(this,me).load(S(this,ue).stakingPoolId,wf)}async systemState(){return await S(this,me).loadFieldObject(S(this,ue).systemObjectId,{type:"u64",value:(await this.systemObject()).version},If)}async stakingState(){return S(this,me).loadFieldObject(S(this,ue).stakingPoolId,{type:"u64",value:(await this.stakingObject()).version},rf)}async computeBlobMetadata({bytes:e,numShards:n}){let r;typeof n=="number"?r=n:r=(await this.systemState()).committee.n_shards;const s=await T(this,I,Nn).call(this),{blobId:i,metadata:a,rootHash:o}=s.computeMetadata(r,e);let c;const l=crypto.getRandomValues(new Uint8Array(32));return{rootHash:o,blobId:i,metadata:{encodingType:a.V1.encoding_type,hashes:Array.from(a.V1.hashes).map(u=>({primaryHash:u.primary_hash,secondaryHash:u.secondary_hash})),unencodedLength:a.V1.unencoded_length},nonce:l,blobDigest:()=>(c||(c=crypto.subtle.digest("SHA-256",e).then(u=>new Uint8Array(u))),c)}}async getBlobMetadata({blobId:e,signal:n}){const r=await T(this,I,ti).call(this,{blobId:e,signal:n}),s=Tp(r.nodes),a=(await this.stakingState()).n_shards;let o=0,c=0,l=0;const u=new AbortController,h=s.map(g=>async()=>{try{return await S(this,Ce).getBlobMetadata({blobId:e},{nodeUrl:g.networkUrl,signal:n?AbortSignal.any([u.signal,n]):u.signal})}catch(p){throw p instanceof pr?o+=g.shardIndices.length:p instanceof Hs&&(c+=g.shardIndices.length),l+=1,p}});try{return await h.shift()()}catch{const p=Math.floor(h.length/S(this,ei)),m=fn(h,p);return await new Promise((b,y)=>{m.forEach(async k=>{for(const A of k)try{const j=await A();u.abort("Blob metadata successfully retrieved."),b(j)}catch(j){if(j instanceof Lt){y(j);return}else if(kn(c+o,a)){const $=o>c?new Pn(`The specified blob ${e} is not certified.`):new pa(`The specified blob ${e} is blocked.`);u.abort($),y($);return}l===h.length&&y(new Pf("No valid blob metadata could be retrieved from any storage node."))}})})}}async internalGetSecondarySliver({blobId:e,index:n,signal:r}){const s=await T(this,I,qe).call(this),a=(await this.stakingState()).n_shards,o=gp(n,a),c=ms(o,e,a),l=await T(this,I,kr).call(this,s,c);if(!l)throw new Error(`No node found for shard index ${c}`);return await S(this,Ce).getSliver({blobId:e,sliverPairIndex:o,sliverType:"secondary"},{nodeUrl:l.networkUrl,signal:r})}async getSlivers({blobId:e,signal:n}){const r=await T(this,I,ti).call(this,{blobId:e,signal:n}),s=Ip(r.nodes.map(y=>({value:y,weight:y.shardIndices.length}))),a=(await this.stakingState()).n_shards,{primarySymbols:o}=gn(a),c=s.flatMap(y=>y.shardIndices.map(k=>({url:y.networkUrl,sliverPairIndex:mp(k,e,a)}))),l=new AbortController,u=fn(c,o),h=[],g=new Set;let p=0,m=0,b=0;return new Promise((y,k)=>{u[0].forEach(async(A,j)=>{for(let $=0;$<u.length;$+=1){const J=u.at($)?.at(j);if(!J)break;const{url:ve,sliverPairIndex:Ye}=J;try{if(g.has(ve))throw new Error(`Skipping node at ${ve} due to previous failure.`);const xe=await S(this,Ce).getSliver({blobId:e,sliverPairIndex:Ye,sliverType:"primary"},{nodeUrl:ve,signal:n?AbortSignal.any([l.signal,n]):l.signal});if(h.length===o){l.abort("Enough slivers successfully retrieved."),y(h);return}h.push(xe)}catch(xe){if(xe instanceof pr)p+=1;else if(xe instanceof Hs)m+=1;else if(xe instanceof Lt){k(xe);return}if(kn(m+p,a)){const ht=p>m?new Pn(`The specified blob ${e} is not certified.`):new pa(`The specified blob ${e} is blocked.`);l.abort(ht),k(ht);return}g.add(ve),b+=1;const _e=c.length-(h.length+b);if(h.length+_e<o){const ht=new Uf(`Unable to retrieve enough slivers to decode blob ${e}.`);l.abort(ht),k(ht)}}}})})}async getVerifiedBlobStatus({blobId:e,signal:n}){const r=await T(this,I,qe).call(this),i=(await this.stakingState()).n_shards,a=new AbortController,u=[...(await new Promise((h,g)=>{const p=[];let m=0,b=0,y=0;r.nodes.forEach(async k=>{const A=k.shardIndices.length;try{const j=await S(this,Ce).getBlobStatus({blobId:e},{nodeUrl:k.networkUrl,signal:n?AbortSignal.any([a.signal,n]):a.signal});kn(m,i)?(a.abort("Quorum of blob statuses retrieved successfully."),h(p)):(m+=A,p.push({status:j,weight:A}))}catch(j){if(j instanceof pr?b+=A:j instanceof Lt&&g(j),kn(b,i)){const $=new Pn("The blob does not exist.");a.abort($),g($)}}finally{y+=1,y===r.nodes.length&&g(new Cf("Not enough statuses were retrieved to achieve quorum."))}})})).reduce((h,g)=>{const{status:p,weight:m}=g,b=JSON.stringify(p),y=h.get(b);return y?y.totalWeight+=m:h.set(b,{status:p,totalWeight:m}),h},new Map).values()].toSorted((h,g)=>la[g.status.type]-la[h.status.type]);for(const h of u)if(wa(h.totalWeight,i))return h.status;throw new jf(`The blob status could not be verified for blob ${e},`)}async storageCost(e,n){const r=await this.systemState(),s=gs(e,r.committee.n_shards),i=pp(s),a=BigInt(i)*BigInt(r.storage_price_per_unit_size)*BigInt(n);BigInt(n);const o=BigInt(i)*BigInt(r.write_price_per_unit_size);return{storageCost:a,writeCost:o,totalCost:a+o}}createStorage({size:e,epochs:n,walCoin:r}){return async s=>{const i=await this.systemObject(),a=await this.systemState(),o=gs(e,a.committee.n_shards),[{storageCost:c},l]=await Promise.all([this.storageCost(e,n),T(this,I,Ut).call(this)]);return s.add(T(this,I,Sr).call(this,c,r??null,(u,h)=>h.add(Of({package:l,arguments:{self:i.id.id,storageAmount:o,epochsAhead:n,payment:u}}))))}}createStorageTransaction({transaction:e=new Ae,size:n,epochs:r,owner:s}){return e.transferObjects([this.createStorage({size:n,epochs:r})],s),e}async executeCreateStorageTransaction({signer:e,...n}){const r=this.createStorageTransaction({...n,owner:n.transaction?.getData().sender??e.toSuiAddress()}),s=await this.getBlobType(),{digest:i,effects:a}=await T(this,I,Pt).call(this,r,e,"create storage"),o=a?.changedObjects.filter(u=>u.idOperation==="Created").map(u=>u.id),l=(await S(this,le).core.getObjects({objectIds:o})).objects.find(u=>!(u instanceof Error)&&u.type===s);if(l instanceof Error||!l)throw new re(`Storage object not found in transaction effects for transaction (${i})`);return{digest:i,storage:Ec.parse(await l.content)}}registerBlob({size:e,epochs:n,blobId:r,rootHash:s,deletable:i,walCoin:a,attributes:o}){return async c=>{const{writeCost:l}=await this.storageCost(e,n),u=await T(this,I,Ut).call(this);return c.add(T(this,I,Sr).call(this,l,a??null,async(h,g)=>{const p=g.add(xf({package:u,arguments:{self:g.object(S(this,ue).systemObjectId),storage:this.createStorage({size:e,epochs:n,walCoin:a}),blobId:jc(r),rootHash:BigInt(d.u256().parse(s)),size:e,encodingType:1,deletable:i,writePayment:h}}));return o&&g.add(T(this,I,si).call(this,{attributes:o,existingAttributes:null,blob:p})),p}))}}addAuthPayload({size:e,blobDigest:n,nonce:r}){return async s=>{const i=await crypto.subtle.digest("SHA-256",r),a=d.u64().serialize(e).toBytes(),o=typeof n=="function"?await n():n,c=new Uint8Array(i.byteLength+o.byteLength+a.byteLength);c.set(o,0),c.set(new Uint8Array(i),o.byteLength),c.set(a,i.byteLength+o.byteLength),s.pure(c)}}async calculateUploadRelayTip(e){const n=await this.systemState(),r=gs(e.size,n.committee.n_shards),s=await T(this,I,ni).call(this);if(!s)return 0n;const{max:i,kind:a}=s,o="const"in a?a.const:BigInt(a.linear.base)+BigInt(a.linear.perEncodedKib)*((BigInt(r)+1023n)/1024n);if(i!=null&&o>i)throw new re(`Tip amount (${o}) exceeds the maximum allowed tip (${i})`);return o}sendUploadRelayTip({size:e,blobDigest:n,nonce:r}){return async s=>{const i=await T(this,I,ni).call(this);if(i){s.add(this.addAuthPayload({size:e,blobDigest:n,nonce:r}));const a=await this.calculateUploadRelayTip({size:e}),{address:o}=i;s.transferObjects([dc({balance:a})],o)}}}registerBlobTransaction({transaction:e=new Ae,...n}){const r=e.add(this.registerBlob(n));return e.transferObjects([r],n.owner),e}async executeRegisterBlobTransaction({signer:e,...n}){const r=this.registerBlobTransaction({...n,owner:n.owner??n.transaction?.getData().sender??e.toSuiAddress()}),s=await this.getBlobType(),{digest:i,effects:a}=await T(this,I,Pt).call(this,r,e,"register blob"),o=a?.changedObjects.filter(u=>u.idOperation==="Created").map(u=>u.id),l=(await S(this,le).core.getObjects({objectIds:o})).objects.find(u=>!(u instanceof Error)&&u.type===s);if(l instanceof Error||!l)throw new re(`Blob object not found in transaction effects for transaction (${i})`);return{digest:i,blob:On.parse(await l.content)}}async certificateFromConfirmations({confirmations:e,blobId:n,deletable:r,blobObjectId:s}){const i=await this.systemState(),a=await T(this,I,qe).call(this);if(e.length!==i.committee.members.length)throw new re("Invalid number of confirmations. Confirmations array must contain an entry for each node");const o=Kf.serialize({intent:Pc.BLOB_CERT_MSG,epoch:i.committee.epoch,messageContents:{blobId:n,blobType:r?{Deletable:{objectId:s}}:{Permanent:null}}}).toBase64(),c=await T(this,I,Nn).call(this),l=c.getVerifySignature(),u=e.map((h,g)=>h?.serializedMessage===o&&l(h,new Uint8Array(a.nodes[g].info.public_key.bytes))?{index:g,...h}:null).filter(h=>h!==null);if(!kn(u.length,i.committee.members.length))throw new fa(`Too many invalid confirmations received for blob (${u.length} of ${i.committee.members.length})`);return c.combineSignatures(u,u.map(({index:h})=>h))}certifyBlob({blobId:e,blobObjectId:n,confirmations:r,certificate:s,deletable:i}){return async a=>{const o=await this.systemState(),c=s??await this.certificateFromConfirmations({confirmations:r,blobId:e,deletable:i,blobObjectId:n}),l=await T(this,I,Ut).call(this);a.add(Mf({package:l,arguments:{self:S(this,ue).systemObjectId,blob:n,signature:a.pure.vector("u8",c.signature),signersBitmap:a.pure.vector("u8",bp(c.signers,o.committee.members.length)),message:a.pure.vector("u8",c.serializedMessage)}}))}}certifyBlobTransaction({transaction:e=new Ae,...n}){return e.add(this.certifyBlob(n)),e}async executeCertifyBlobTransaction({signer:e,...n}){const r=this.certifyBlobTransaction(n),{digest:s}=await T(this,I,Pt).call(this,r,e,"certify blob");return{digest:s}}deleteBlob({blobObjectId:e}){return async n=>{const r=await T(this,I,Ut).call(this);return n.add(Af({package:r,arguments:{self:S(this,ue).systemObjectId,blob:e}}))}}deleteBlobTransaction({owner:e,blobObjectId:n,transaction:r=new Ae}){const s=r.add(this.deleteBlob({blobObjectId:n}));return r.transferObjects([s],e),r}async executeDeleteBlobTransaction({signer:e,transaction:n=new Ae,blobObjectId:r}){const{digest:s}=await T(this,I,Pt).call(this,this.deleteBlobTransaction({blobObjectId:r,transaction:n,owner:n.getData().sender??e.toSuiAddress()}),e,"delete blob");return{digest:s}}extendBlob({blobObjectId:e,epochs:n,endEpoch:r,walCoin:s}){return async i=>{const a=await S(this,me).load(e,On),o=typeof n=="number"?n:r-a.storage.end_epoch;if(o<=0)return;const{storageCost:c}=await this.storageCost(Number(a.storage.storage_size),o),l=await T(this,I,Ut).call(this);return i.add(T(this,I,Sr).call(this,c,s??null,async(u,h)=>{h.add(Bf({package:l,arguments:{self:S(this,ue).systemObjectId,blob:e,extendedEpochs:o,payment:u}}))}))}}async extendBlobTransaction({transaction:e=new Ae,...n}){return e.add(this.extendBlob(n)),e}async executeExtendBlobTransaction({signer:e,...n}){const{digest:r}=await T(this,I,Pt).call(this,await this.extendBlobTransaction(n),e,"extend blob");return{digest:r}}async readBlobAttributes({blobObjectId:e}){const n=await S(this,le).core.getDynamicField({parentId:e,name:{type:"vector<u8>",bcs:d.string().serialize("metadata").toBytes()}}),r=Qh.parse(n.dynamicField.value.bcs);return Object.fromEntries(r.metadata.contents.map(({key:s,value:i})=>[s,i]))}writeBlobAttributes({blobObject:e,blobObjectId:n,attributes:r}){return async s=>{const i=n?await this.readBlobAttributes({blobObjectId:n}):null,a=e??s.object(n);s.add(T(this,I,si).call(this,{attributes:r,existingAttributes:i,blob:a}))}}async writeBlobAttributesTransaction({transaction:e=new Ae,...n}){return e.add(await this.writeBlobAttributes(n)),e}async executeWriteBlobAttributesTransaction({signer:e,...n}){const{digest:r}=await T(this,I,Pt).call(this,await this.writeBlobAttributesTransaction(n),e,"write blob attributes");return{digest:r}}async writeSliver({blobId:e,sliverPairIndex:n,sliverType:r,sliver:s,signal:i}){const a=await this.systemState(),o=await T(this,I,qe).call(this),c=ms(n,e,a.committee.n_shards),l=await T(this,I,kr).call(this,o,c);return S(this,Ce).storeSliver({blobId:e,sliverPairIndex:n,sliverType:r,sliver:s},{nodeUrl:l.networkUrl,signal:i})}async writeMetadataToNode({nodeIndex:e,blobId:n,metadata:r,signal:s}){const a=(await T(this,I,qe).call(this)).nodes[e];return Jp(()=>S(this,Ce).storeBlobMetadata({blobId:n,metadata:r},{nodeUrl:a.networkUrl,signal:s}),{count:3,delay:1e3,condition:o=>o instanceof Wc})}async getStorageConfirmationFromNode({nodeIndex:e,blobId:n,deletable:r,objectId:s,signal:i}){const o=(await T(this,I,qe).call(this)).nodes[e];return(r?await S(this,Ce).getDeletableBlobConfirmation({blobId:n,objectId:s},{nodeUrl:o.networkUrl,signal:i}):await S(this,Ce).getPermanentBlobConfirmation({blobId:n},{nodeUrl:o.networkUrl,signal:i}))?.success?.data?.signed??null}async encodeBlob(e){const n=await this.systemState(),r=await T(this,I,qe).call(this),s=n.committee.n_shards,i=await T(this,I,Nn).call(this),{blobId:a,metadata:o,sliverPairs:c,rootHash:l}=i.encodeBlob(s,e),u=new Map;for(;c.length>0;){const{primary:g,secondary:p}=c.pop(),m=g.index,b=ms(m,a,s),y=await T(this,I,kr).call(this,r,b);u.has(y.nodeIndex)||u.set(y.nodeIndex,{primary:[],secondary:[]}),u.get(y.nodeIndex).primary.push({sliverIndex:g.index,sliverPairIndex:m,shardIndex:b,sliver:Ot.serialize(g).toBytes()}),u.get(y.nodeIndex).secondary.push({sliverIndex:p.index,sliverPairIndex:m,shardIndex:b,sliver:Ot.serialize(p).toBytes()})}const h=new Array;for(let g=0;g<n.committee.members.length;g++)h.push(u.get(g)??{primary:[],secondary:[]});return{blobId:a,metadata:o,rootHash:l,sliversByNode:h}}async writeSliversToNode({blobId:e,slivers:n,signal:r}){const s=new AbortController,i=r?AbortSignal.any([s.signal,r]):s.signal,a=n.primary.map(({sliverPairIndex:c,sliver:l})=>this.writeSliver({blobId:e,sliverPairIndex:c,sliverType:"primary",sliver:l,signal:i})),o=n.secondary.map(({sliverPairIndex:c,sliver:l})=>this.writeSliver({blobId:e,sliverPairIndex:c,sliverType:"secondary",sliver:l,signal:i}));await Promise.all([...a,...o]).catch(c=>{throw s.abort(c),c})}async writeEncodedBlobToNodes({blobId:e,metadata:n,sliversByNode:r,signal:s,...i}){const a=await this.systemState(),o=await T(this,I,qe).call(this),c=new AbortController;let l=0;return await Promise.all(r.map((h,g)=>this.writeEncodedBlobToNode({blobId:e,nodeIndex:g,metadata:n,slivers:h,signal:s?AbortSignal.any([c.signal,s]):c.signal,...i}).catch(()=>{if(l+=o.nodes[g].shardIndices.length,wa(l,a.committee.n_shards)){const p=new fa(`Too many failures while writing blob ${e} to nodes`);throw c.abort(p),p}return null})))}async writeBlobToUploadRelay(e){if(!S(this,ae))throw new re("Upload relay not configured");return S(this,ae).writeBlob({...e,requiresTip:!!S(this,ze)?.sendTip})}async writeEncodedBlobToNode({nodeIndex:e,blobId:n,metadata:r,slivers:s,signal:i,...a}){return await this.writeMetadataToNode({nodeIndex:e,blobId:n,metadata:r,signal:i}),await this.writeSliversToNode({blobId:n,slivers:s,signal:i,nodeIndex:e}),this.getStorageConfirmationFromNode({nodeIndex:e,blobId:n,...a})}async writeBlob({blob:e,deletable:n,epochs:r,signer:s,signal:i,owner:a,attributes:o}){if(S(this,ze)){const c=await this.computeBlobMetadata({bytes:e}),l=c.blobId,u=new Ae;u.add(this.sendUploadRelayTip({size:e.length,blobDigest:c.blobDigest,nonce:c.nonce}));const h=await this.executeRegisterBlobTransaction({signer:s,transaction:u,size:e.length,epochs:r,blobId:c.blobId,rootHash:c.rootHash,deletable:n,owner:a??s.toSuiAddress(),attributes:o});await S(this,le).core.waitForTransaction({digest:h.digest});const p=(await this.writeBlobToUploadRelay({blobId:l,blob:e,nonce:c.nonce,txDigest:h.digest,signal:i,deletable:n,blobObjectId:h.blob.id.id,encodingType:c.metadata.encodingType})).certificate,m=h.blob.id.id;return await this.executeCertifyBlobTransaction({signer:s,blobId:l,blobObjectId:m,certificate:p,deletable:n}),{blobId:l,blobObject:await S(this,me).load(m,On)}}else{const c=await this.encodeBlob(e),l=c.blobId,{sliversByNode:u,metadata:h,rootHash:g}=c,m=(await this.executeRegisterBlobTransaction({signer:s,size:e.length,epochs:r,blobId:l,rootHash:g,deletable:n,owner:a??s.toSuiAddress(),attributes:o})).blob.id.id,b=await this.writeEncodedBlobToNodes({blobId:l,metadata:h,sliversByNode:u,deletable:n,objectId:m,signal:i});return await this.executeCertifyBlobTransaction({signer:s,blobId:l,blobObjectId:m,confirmations:b,deletable:n}),{blobId:l,blobObject:await S(this,me).load(m,On)}}}async writeQuilt({blobs:e,...n}){const r=await this.encodeQuilt({blobs:e}),s=await this.writeBlob({blob:r.quilt,...n});return{...s,index:{...r.index,patches:r.index.patches.map(i=>({...i,patchId:Oa({quiltId:s.blobId,patchId:{version:1,startIndex:i.startIndex,endIndex:i.endIndex}})}))}}}async encodeQuilt({blobs:e}){const n=await this.systemState();return Fp({blobs:e,numShards:n.committee.n_shards})}reset(){S(this,me).clearAll(),S(this,Fe).clear()}async getBlob({blobId:e}){return new Qp({reader:new Aa({client:this,blobId:e,numShards:(await this.systemState()).committee.n_shards}),client:this})}async getFiles({ids:e}){const n=new Map,r=new Map,s=e.map(a=>Wp(a)),i=(await this.systemState()).committee.n_shards;for(const a of s){const o=a.kind==="blob"?a.id:a.id.quiltId;n.has(o)||n.set(o,new Aa({client:this,blobId:o,numShards:i})),a.kind==="quiltPatch"&&(r.has(o)||r.set(o,new nu({blob:n.get(o)})))}return s.map(a=>a.kind==="blob"?new Lr({reader:n.get(a.id)}):new Lr({reader:new Js({quilt:r.get(a.id.quiltId),sliverIndex:a.id.patchId.startIndex})}))}async writeFiles({files:e,...n}){const{blobId:r,index:s,blobObject:i}=await this.writeQuilt({...n,blobs:await Promise.all(e.map(async(a,o)=>({contents:await a.bytes(),identifier:await a.getIdentifier()??`file-${o}`,tags:await a.getTags()??{}})))});return s.patches.map(a=>({id:a.patchId,blobId:r,blobObject:i}))}writeFilesFlow({files:e}){const n=async()=>{const{quilt:l,index:u}=await this.encodeQuilt({blobs:await Promise.all(e.map(async(g,p)=>({contents:await g.bytes(),identifier:await g.getIdentifier()??`file-${p}`,tags:await g.getTags()??{}})))});return{metadata:S(this,ae)?await this.computeBlobMetadata({bytes:l}):await this.encodeBlob(l),size:l.length,data:S(this,ae)?l:void 0,index:u}},r=({data:l,metadata:u,index:h,size:g},{epochs:p,deletable:m,owner:b,attributes:y})=>{const k=new Ae;if(k.setSenderIfNotSet(b),S(this,ae)){const A=u;k.add(this.sendUploadRelayTip({size:g,blobDigest:A.blobDigest,nonce:A.nonce}))}return k.transferObjects([this.registerBlob({size:g,epochs:p,blobId:u.blobId,rootHash:u.rootHash,deletable:m,attributes:y})],b),{registerTransaction:k,index:h,data:l,metadata:u,deletable:m}},s=async({index:l,data:u,metadata:h,deletable:g},{digest:p})=>{const m=await T(this,I,ri).call(this,p);if(S(this,ae)){const y=h;return{index:l,blobObject:m,metadata:h,deletable:g,certificate:(await this.writeBlobToUploadRelay({blobId:h.blobId,blob:u,nonce:y.nonce,txDigest:p,blobObjectId:m.id.id,deletable:g,encodingType:y.metadata.encodingType})).certificate}}const b=h;return{index:l,blobObject:m,metadata:h,deletable:g,confirmations:await this.writeEncodedBlobToNodes({blobId:h.blobId,objectId:m.id.id,metadata:b.metadata,sliversByNode:b.sliversByNode,deletable:g})}},i=({index:l,metadata:u,confirmations:h,certificate:g,blobObject:p,deletable:m})=>({index:l,blobObject:p,metadata:u,transaction:h?this.certifyBlobTransaction({blobId:u.blobId,blobObjectId:p.id.id,confirmations:h,deletable:m}):this.certifyBlobTransaction({certificate:g,blobId:u.blobId,blobObjectId:p.id.id,deletable:m})});async function a({index:l,blobObject:u,metadata:h}){return l.patches.map(g=>({id:Oa({quiltId:h.blobId,patchId:{version:1,startIndex:g.startIndex,endIndex:g.endIndex}}),blobId:h.blobId,blobObject:u}))}const o={};function c(l,u){if(!o[l])throw new Error(`${l} must be executed before calling ${u}`);return o[l]}return{encode:async()=>{o.encode||(o.encode=await n())},register:l=>(o.register=r(c("encode","register"),l),o.register.registerTransaction),upload:async l=>{o.upload=await s(c("register","upload"),l)},certify:()=>(o.certify=i(c("upload","certify")),o.certify.transaction),listFiles:async()=>a(c("certify","listFiles"))}}writeBlobFlow({blob:e}){const n=async()=>({metadata:S(this,ae)?await this.computeBlobMetadata({bytes:e}):await this.encodeBlob(e),size:e.length,data:S(this,ae)?e:void 0}),r=({data:l,metadata:u,size:h},{epochs:g,deletable:p,owner:m,attributes:b})=>{const y=new Ae;if(y.setSenderIfNotSet(m),S(this,ae)){const k=u;y.add(this.sendUploadRelayTip({size:h,blobDigest:k.blobDigest,nonce:k.nonce}))}return y.transferObjects([this.registerBlob({size:h,epochs:g,blobId:u.blobId,rootHash:u.rootHash,deletable:p,attributes:b})],m),{registerTransaction:y,data:l,metadata:u,deletable:p}},s=async({data:l,metadata:u,deletable:h},{digest:g})=>{const p=await T(this,I,ri).call(this,g);if(S(this,ae)){const b=u;return{blobObject:p,metadata:u,deletable:h,certificate:(await this.writeBlobToUploadRelay({blobId:u.blobId,blob:l,nonce:b.nonce,txDigest:g,blobObjectId:p.id.id,deletable:h,encodingType:b.metadata.encodingType})).certificate}}const m=u;return{blobObject:p,metadata:u,deletable:h,confirmations:await this.writeEncodedBlobToNodes({blobId:u.blobId,objectId:p.id.id,metadata:m.metadata,sliversByNode:m.sliversByNode,deletable:h})}},i=({metadata:l,confirmations:u,certificate:h,blobObject:g,deletable:p})=>({blobObject:g,metadata:l,transaction:u?this.certifyBlobTransaction({blobId:l.blobId,blobObjectId:g.id.id,confirmations:u,deletable:p}):this.certifyBlobTransaction({certificate:h,blobId:l.blobId,blobObjectId:g.id.id,deletable:p})});async function a({blobObject:l,metadata:u}){return{blobId:u.blobId,blobObject:l}}const o={};function c(l,u){if(!o[l])throw new Error(`${l} must be executed before calling ${u}`);return o[l]}return{encode:async()=>{o.encode||(o.encode=await n())},register:l=>(o.register=r(c("encode","register"),l),o.register.registerTransaction),upload:async l=>{o.upload=await s(c("register","upload"),l)},certify:()=>(o.certify=i(c("upload","certify")),o.certify.transaction),getBlob:async()=>a(c("certify","getBlob"))}}};Ce=new WeakMap;Hr=new WeakMap;ue=new WeakMap;le=new WeakMap;me=new WeakMap;ei=new WeakMap;Rn=new WeakMap;Fe=new WeakMap;ze=new WeakMap;ae=new WeakMap;I=new WeakSet;hu=function(){return S(this,Fe).read(["walType"],async()=>{const e=(await S(this,le).jsonRpc.getNormalizedMoveStruct({package:await T(this,I,Ri).call(this),module:"staked_wal",struct:"StakedWal"})).fields.find(s=>s.name==="principal")?.type;if(!e)throw new re("WAL type not found");const r=ut(xn(e)).typeParams[0];if(!r)throw new re("WAL type not found");return Gt(r)})};Ri=function(){return S(this,Fe).read(["getPackageId"],async()=>{const t=await S(this,me).load(S(this,ue).systemObjectId);return ut(t.type).address})};Ut=function(){return S(this,Fe).read(["getSystemPackageId"],async()=>{const{package_id:t}=await this.systemObject();return t})};Nn=function(){return S(this,Fe).read(["wasmBindings"],async()=>Pp(S(this,Hr)))};fu=async function({blobId:t,signal:e}){const n=await this.systemState(),r=n.committee.n_shards,s=await this.getBlobMetadata({blobId:t,signal:e}),i=await this.getSlivers({blobId:t,signal:e}),a=await T(this,I,Nn).call(this),o=a.decodePrimarySlivers(t,r,s.metadata.V1.unencoded_length,i);if(a.computeMetadata(n.committee.n_shards,o).blobId!==t)throw new Nf("The specified blob was encoded incorrectly.");return o};pu=async function({blobId:t,signal:e}){const n=await this.stakingState(),r=n.epoch;if(n.epoch_state.$kind==="EpochChangeSync"){const s=await this.getVerifiedBlobStatus({blobId:t,signal:e});if(s.type==="nonexistent"||s.type==="invalid")throw new Pn(`The specified blob ${t} is ${s.type}.`);if(typeof s.initialCertifiedEpoch!="number")throw new Pn(`The specified blob ${t} is not certified.`);if(s.initialCertifiedEpoch>r)throw new Rf(`The client is at epoch ${r} while the specified blob was certified at epoch ${s.initialCertifiedEpoch}.`);return s.initialCertifiedEpoch}return r};ti=async function(t){return S(this,Rn)||Be(this,Rn,T(this,I,gu).call(this,t)),S(this,Rn)};gu=async function({blobId:t,signal:e}){const n=await this.stakingState(),r=n.epoch_state.$kind==="EpochChangeSync",s=await T(this,I,pu).call(this,{blobId:t,signal:e});return r&&s<n.epoch?await T(this,I,Ni).call(this,n.previous_committee):await T(this,I,qe).call(this)};Sr=function(t,e,n){return async r=>{const s=await T(this,I,hu).call(this),i=e?r.splitCoins(e,[t])[0]:r.add(dc({balance:t,type:s})),a=await n(i,r);return r.moveCall({target:"0x2::coin::destroy_zero",typeArguments:[s],arguments:[i]}),a}};ni=function(){return S(this,Fe).read(["upload-relay-tip-config"],async()=>{if(!S(this,ze)?.sendTip||!S(this,ae))return null;if("kind"in S(this,ze).sendTip)return S(this,ze).sendTip;const t=await S(this,ae).tipConfig();return t?{...t,max:S(this,ze).sendTip.max}:null})};ri=async function(t){const e=await this.getBlobType(),{transaction:{effects:n}}=await S(this,le).core.waitForTransaction({digest:t}),r=n?.changedObjects.filter(a=>a.idOperation==="Created").map(a=>a.id),i=(await S(this,le).core.getObjects({objectIds:r})).objects.find(a=>!(a instanceof Error)&&a.type===e);if(i instanceof Error||!i)throw new re(`Blob object not found in transaction effects for transaction (${t})`);return On.parse(await i.content)};si=function({attributes:t,existingAttributes:e,blob:n}){return async r=>{const s=await T(this,I,Ut).call(this);e||r.add(Lh({package:s,arguments:{self:n,metadata:Jh({package:s})}})),Object.keys(t).forEach(i=>{const a=t[i];a===null?e&&i in e&&r.add(Hh({package:s,arguments:{self:n,key:i}})):r.add(Gh({package:s,arguments:{self:n,key:i,value:a}}))})}};Pt=async function(t,e,n){t.setSenderIfNotSet(e.toSuiAddress());const{digest:r,effects:s}=await e.signAndExecuteTransaction({transaction:t,client:S(this,le)});if(s?.status.error)throw new re(`Failed to ${n} (${r}): ${s?.status.error}`);return await S(this,le).core.waitForTransaction({digest:r}),{digest:r,effects:s}};Ni=async function(t){const e=await T(this,I,mu).call(this,t),n=yp(t),r=new Map,s=e.map(({node_info:i},a)=>{const o=n.get(i.node_id)??[],c={id:i.node_id,info:i,networkUrl:`https://${i.network_address}`,shardIndices:o,nodeIndex:a};for(const l of o)r.set(l,c);return c});return{byShardIndex:r,nodes:s}};qe=function(){return S(this,Fe).read(["getActiveCommittee"],async()=>{const t=await this.stakingState();return T(this,I,Ni).call(this,t.committee)})};mu=async function(t){const e=t[0].contents.map(n=>n.key);return S(this,me).loadManyOrThrow(e,bf)};kr=async function(t,e){const n=t.byShardIndex.get(e);if(!n)throw new re(`Node for shard index ${e} not found`);return n};ii=function(t){return async(...e)=>{try{return await t.apply(this,e)}catch(n){if(n instanceof bn)return this.reset(),await t.apply(this,e);throw n}}};let $g=Xp;export{C as $,yg as A,lo as B,wg as C,dl as D,hl as E,fo as F,pg as G,fg as H,dg as I,rg as J,gg as K,ig as L,hg as M,Kt as N,sg as O,il as P,og as Q,Vn as R,mg as S,Ae as T,lg as U,f as V,oo as W,ng as X,Wt as Y,Mr as Z,go as _,O as a,Qr as a0,Tl as a1,Eh as a2,It as a3,Gt as a4,zo as a5,Th as a6,$h as a7,vc as a8,d as a9,hn as aa,Zp as ab,us as ac,cg as ad,ag as ae,Va as af,Ig as ag,Uh as ah,Tg as ai,Yp as aj,Lr as ak,$g as al,Cc as am,R as b,Y as c,eg as d,Eg as e,Yr as f,yu as g,Q as h,ug as i,vg as j,_g as k,x as l,Sg as m,F as n,v as o,W as p,bg as q,kg as r,M as s,X as t,ad as u,od as v,ho as w,po as x,Br as y,uo as z};
